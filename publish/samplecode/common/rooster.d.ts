// Type definitions for roosterjs
// Generated by dts tool from roosterjs
// Project: https://github.com/Microsoft/roosterjs

declare namespace roosterjs {
    /**
     * Create an editor instance with most common options
     * @param contentDiv The html div element needed for creating the editor
     * @param additionalPlugins The additional user defined plugins. Currently the default plugins that are already included are
     * DefalutShortcut, HyperLink, Paste, and ContentEdit, user don't need to add those.
     * @param initialContent The initial content to show in editor. It can't be removed by undo, user need to manually remove it if needed.
     * @returns The editor instance
     */
    function createEditor(contentDiv: HTMLDivElement, additionalPlugins?: EditorPlugin[], initialContent?: string): Editor;

    const enum Alignment {
        Left = 0,
        Center = 1,
        Right = 2,
    }

    const enum Direction {
        LeftToRight = 0,
        RightToLeft = 1,
    }

    const enum Indentation {
        Increase = 0,
        Decrease = 1,
    }

    interface LinkData {
        scheme: string;
        originalUrl: string;
        normalizedUrl: string;
    }

    const enum ListState {
        None = 0,
        Bullets = 1,
        Numbering = 2,
    }

    /**
     * Table format
     */
    interface TableFormat {
        /**
         * Background color for even rows
         */
        bgColorEven: string;
        /**
         * Background color for odd rows
         */
        bgColorOdd: string;
        /**
         * Top border color for each row
         */
        topBorderColor: string;
        /**
         * Bottom border color for each row
         */
        bottomBorderColor: string;
        /**
         * Vertical border color for each row
         */
        verticalBorderColor: string;
    }

    const enum TableOperation {
        /**
         * Insert a row above current row
         */
        InsertAbove = 0,
        /**
         * Insert a row below current row
         */
        InsertBelow = 1,
        /**
         * Insert a column on the left of current column
         */
        InsertLeft = 2,
        /**
         * Insert a column on the right of current column
         */
        InsertRight = 3,
        /**
         * Delete the whole table
         */
        DeleteTable = 4,
        /**
         * Delete current column
         */
        DeleteColumn = 5,
        /**
         * Delete current row
         */
        DeleteRow = 6,
        /**
         * Merge current row with the row above
         */
        MergeAbove = 7,
        /**
         * Merge current row with the row below
         */
        MergeBelow = 8,
        /**
         * Merge current column with the column on the left
         */
        MergeLeft = 9,
        /**
         * Merge current column with the column on the right
         */
        MergeRight = 10,
        /**
         * Split current table cell horizontally
         */
        SplitHorizontally = 11,
        /**
         * Split current table cell vertically
         */
        SplitVertically = 12,
    }

    interface ClipboardData {
        snapshotBeforePaste: string;
        originalFormat: DefaultFormat;
        types: string[];
        image: File;
        text: string;
        html: string;
        isHtmlFromTempDiv?: boolean;
    }

    /**
     * The position. Mostly used for content insertion and traversing
     * On insertion, we will need to specify where we want the content to be placed (begin, end, selection or outside)
     * On content traversing, we will need to specify the start position of traversing
     */
    const enum ContentPosition {
        /**
         * Begin of the container
         */
        Begin = 0,
        /**
         * End of the container
         */
        End = 1,
        /**
         * Selection start
         */
        SelectionStart = 2,
        /**
         * Outside of editor
         */
        Outside = 3,
    }

    const enum ContentScope {
        Block = 0,
        Selection = 1,
        Body = 2,
    }

    interface InsertOption {
        position: ContentPosition;
        updateCursor: boolean;
        replaceSelection: boolean;
        insertOnNewLine: boolean;
    }

    interface ContentChangedEvent extends PluginEvent {
        source: ChangeSource | string;
        data?: any;
    }

    const enum ChangeSource {
        AutoLink = "AutoLink",
        CreateLink = "CreateLink",
        Format = "Format",
        ImageResize = "ImageResize",
        Paste = "Paste",
        SetContent = "SetContent",
        Undo = "Undo",
    }

    interface ExtractContentEvent extends PluginEvent {
        content: string;
    }

    interface PluginDomEvent extends PluginEvent {
        rawEvent: Event;
    }

    interface PluginEvent {
        eventType: PluginEventType;
        eventDataCache?: {
            [key: string]: any;
        };
    }

    /**
     * Editor plugin event type
     */
    const enum PluginEventType {
        /**
         * HTML KeyDown event
         */
        KeyDown = 0,
        /**
         * HTML KeyPress event
         */
        KeyPress = 1,
        /**
         * HTML KeyUp event
         */
        KeyUp = 2,
        /**
         * HTML CompositionEnd event
         */
        CompositionEnd = 3,
        /**
         * HTML MouseDown event
         */
        MouseDown = 4,
        /**
         * HTML MouseUp event
         */
        MouseUp = 5,
        /**
         * Content changed event
         */
        ContentChanged = 6,
        /**
         * Extract Content event
         * This event is triggered when getContent() is called with triggerExtractContentEvent = true
         * Plugin can handle this event to remove the UI only markups to return clean HTML
         */
        ExtractContent = 7,
        /**
         * Before Paste event, provide a chance to change paste content
         */
        BeforePaste = 8,
    }

    interface BeforePasteEvent extends PluginEvent {
        clipboardData: ClipboardData;
        fragment: DocumentFragment;
        pasteOption: PasteOption;
    }

    const enum DocumentPosition {
        Same = 0,
        Disconnected = 1,
        Preceding = 2,
        Following = 4,
        Contains = 8,
        ContainedBy = 16,
        ImplementationSpecific = 32,
    }

    const enum NodeType {
        Element = 1,
        Text = 3,
        ProcessingInstruction = 7,
        Comment = 8,
        Document = 9,
        DocumentType = 10,
        DocumentFragment = 11,
    }

    interface DefaultFormat {
        fontFamily?: string;
        fontSize?: string;
        textColor?: string;
        backgroundColor?: string;
        bold?: boolean;
        italic?: boolean;
        underline?: boolean;
    }

    interface FormatState {
        fontName?: string;
        fontSize?: string;
        isBold?: boolean;
        isItalic?: boolean;
        isUnderline?: boolean;
        backgroundColor?: string;
        textColor?: string;
        isBullet?: boolean;
        isNumbering?: boolean;
        isStrikeThrough?: boolean;
        isBlockQuote?: boolean;
        isSubscript?: boolean;
        isSuperscript?: boolean;
        canUnlink?: boolean;
        canAddImageAltText?: boolean;
        canUndo?: boolean;
        canRedo?: boolean;
        headerLevel?: number;
    }

    interface Rect {
        top: number;
        bottom: number;
        left: number;
        right: number;
    }

    /**
     * Paste option
     */
    const enum PasteOption {
        /**
         * Paste html with content type "text/html"
         */
        PasteHtml = 0,
        /**
         * Paste plain text with content type "text/plain"
         */
        PasteText = 1,
        /**
         * Paste image from clipboard with content type "image/*"
         */
        PasteImage = 2,
    }

    class Position {
        static readonly Before: PositionType;
        static readonly Begin: PositionType;
        static readonly End: PositionType;
        static readonly After: PositionType;
        readonly node: Node;
        readonly offset: number;
        readonly isAtEnd: boolean;
        /**
         * Clone and validate a position from existing position.
         * If the given position has invalid offset, this function will return a corrected value.
         * @param position The original position to clone from
         */
        constructor(position: Position);
        /**
         * Create a Position from node and an offset number
         * @param node The node of this position
         * @param offset Offset of this position
         */
        constructor(node: Node, offset: number);
        /**
         * Create a Position from node and a type of position
         * @param node The node of this position
         * @param positionType Type of the postion, can be Begin, End, Before, After
         */
        constructor(node: Node, positionType: PositionType);
        normalize(): Position;
        equalTo(p: Position): boolean;
        /**
         * Checks if position 1 is after position 2
         */
        isAfter(p: Position): boolean;
    }

    class SelectionRange {
        readonly collapsed: boolean;
        readonly start: Position;
        readonly end: Position;
        private rawRange;
        constructor(rawRange: Range);
        constructor(start: Position, end?: Position);
        getRange(): Range;
        normalize(): SelectionRange;
    }

    const enum PositionType {
        Before = "b",
        Begin = 0,
        End = "e",
        After = "a",
    }

    /**
     * This walks forwards (from left to right) DOM tree to get next meaningful node
     * A null is returned when it reaches the very end - beyond the scope as defined by rootNode
     */
    function getNextLeafSibling(rootNode: Node, startNode: Node): Node;

    /**
     * This walks backwards (from right to left) DOM tree to get previous meaningful node
     * A null is returned when it reaches the very first - beyond the scope as defined by rootNode
     */
    function getPreviousLeafSibling(rootNode: Node, startNode: Node): Node;

    /**
     * Get the first meaningful leaf node
     * This can return null for empty container or
     * container that does not contain any meaningful node
     */
    function getFirstLeafNode(rootNode: Node): Node;

    /**
     * Get the last meaningful leaf node
     * This can return null for empty container or
     * container that does not contain any meaningful node
     */
    function getLastLeafNode(rootNode: Node): Node;

    /**
     * This refers to an inline element (as opposed to block) in editor
     * Inline and block makes the "type" system in editor.
     * An inline element is a maximum resolvable "entity" within the boundary of a block
     * At minimum and also most commonly, it represents a text node.
     * It can represent broader "content" depending on the resolvers that are available, i.e.
     * it can be anchor link, image, emoji, ...
     * Two rules:
     * 1) every inline element must have a container node (text or span, a etc.)
     * 2) inline element cannot be nested
     */
    interface InlineElement {
        /**
         * Get the text content of this inline element
         */
        getTextContent: () => string;
        /**
         * Get the container node of this inline element
         */
        getContainerNode: () => Node;
        /**
         * Get the start position of this inline element
         */
        getStartPosition: () => Position;
        /**
         * Get the end position of this inline element
         */
        getEndPosition: () => Position;
        /**
         * Checks if the given inline element is after this inline element
         */
        isAfter: (inlineElement: InlineElement) => boolean;
        /**
         * Checks if the given editor position is contained in this inline element
         */
        contains: (position: Position) => boolean;
        /**
         * Apply inline style to a region of an inline element. The region is identified thorugh the from and to point
         * The fromPosition and toPosition are optional and when bing missed, it indicates the boundary of the element
         * The function finds the minimal DOM on top of which styles can be applied, or create DOM when needed, i.e.
         * when the style has to be applied to partial of a text node, in that case, it wraps that in a SPAN and returns the SPAN
         * The actuall styling is done by consumer through the styler callback
         */
        applyStyle: (styler: (node: Node) => void, from?: Position, to?: Position) => void;
    }

    /**
     * This presents an inline element that can be reprented by a single html node.
     * This serves as base for most inline element as it contains most implentation
     * of all operations that can happen on an inline element. Other sub inline elements mostly
     * just identify themself for a certain type
     */
    class NodeInlineElement implements InlineElement {
        private containerNode;
        constructor(containerNode: Node);
        /**
         * The text content for this inline element
         */
        getTextContent(): string;
        /**
         * Get the container node
         */
        getContainerNode(): Node;
        /**
         * Get the start point of the inline element
         */
        getStartPosition(): Position;
        /**
         * Get the end point of the inline element
         */
        getEndPosition(): Position;
        /**
         * Checks if an inline element is after the current inline element
         */
        isAfter(inlineElement: InlineElement): boolean;
        /**
         * Checks if an editor point is contained in the inline element
         */
        contains(position: Position): boolean;
        /**
         * Apply inline style to a region of an inline element. The region is identified thorugh the from and to point
         * The fromPosition and toPosition are optional and when bing missed, it indicates the boundary of the element
         * The function finds the minimal DOM on top of which styles can be applied, or create DOM when needed, i.e.
         * when the style has to be applied to partial of a text node, in that case, it wraps that in a SPAN and returns the SPAN
         * The actuall styling is done by consumer through the styler callback
         */
        applyStyle(styler: (node: Node) => void, from?: Position, to?: Position): void;
    }

    /**
     * This is a special version of inline element that identifies a section of an inline element
     * We often have the need to cut an inline element in half and perform some operation only on half of an inline element
     * i.e. users select only some text of a text node and apply format, in that case, format has to happen on partial of an inline element
     * PartialInlineElement is implemented in a way that decorate another full inline element with its own override on methods like isAfter
     * It also offers some special methods that others don't have, i.e. nextInlineElement etc.
     */
    class PartialInlineElement implements InlineElement {
        private inlineElement;
        private start;
        private end;
        constructor(inlineElement: InlineElement, start?: Position, end?: Position);
        /**
         * Get the full inline element that this partial inline decorates
         */
        getDecoratedInline(): InlineElement;
        /**
         * Gets the container node
         */
        getContainerNode(): Node;
        /**
         * Gets the text content
         */
        getTextContent(): string;
        /**
         * Gets the start position
         */
        getStartPosition(): Position;
        /**
         * Gets the end position
         */
        getEndPosition(): Position;
        /**
         * Checks if the partial is on start point
         */
        isStartPartial(): boolean;
        /**
         * Checks if the partial is on the end point
         */
        isEndPartial(): boolean;
        /**
         * Get next partial inline element if it is not at the end boundary yet
         */
        readonly nextInlineElement: PartialInlineElement;
        /**
         * Get previous partial inline element if it is not at the begin boundary yet
         */
        readonly previousInlineElement: PartialInlineElement;
        /**
         * Checks if it contains a position
         */
        contains(p: Position): boolean;
        /**
         * Check if this inline element is after the other inline element
         */
        isAfter(inlineElement: InlineElement): boolean;
        /**
         * apply style
         */
        applyStyle(styler: (node: Node) => void, from?: Position, to?: Position): void;
    }

    /**
     * Get the inline element at a node
     * @param node The node to get InlineElement froms
     */
    function getInlineElementAtNode(node: Node): InlineElement;

    /**
     * Get first inline element
     */
    function getFirstInlineElement(rootNode: Node): InlineElement;

    /**
     * Get last inline element
     */
    function getLastInlineElement(rootNode: Node): InlineElement;

    /**
     * Get next inline element
     */
    function getNextInlineElement(rootNode: Node, inlineElement: InlineElement): InlineElement;

    /**
     * Get previous inline element
     */
    function getPreviousInlineElement(rootNode: Node, inlineElement: InlineElement): InlineElement;

    /**
     * This refers to a "content block" in editor that serves as a content parsing boundary
     * It is most those html block like tags, i.e. <p>, <div>, <li>, <td> etc.
     * but can also be just a text node, followed by a <br>, i.e.
     * for html fragment <div>abc<br>123</div>, abc<br> is a block, 123 is another block
     */
    interface BlockElement {
        /**
         * Get text content of this block element
         */
        getTextContent(): string;
        /**
         * Get start node of this block element
         */
        getStartNode(): Node;
        /**
         * Get end node of this block element
         */
        getEndNode(): Node;
        /**
         * Get content nodes of this block element as node array
         */
        getContentNodes(): Node[];
        /**
         * Get the first inline element of this block element
         */
        getFirstInlineElement(): InlineElement;
        /**
         * Get the last inline element of this block element
         */
        getLastInlineElement(): InlineElement;
        /**
         * Check whether this block element equals to the given block element
         */
        equals(blockElement: BlockElement): boolean;
        /**
         * Checks if this block element is after another block element
         */
        isAfter(blockElement: BlockElement): boolean;
        /**
         * Check if the given inline element falls within this block element
         */
        contains(inlineElement: InlineElement): boolean;
        /**
         * Check if the given node is within this block element
         */
        contains(node: Node): boolean;
    }

    /**
     * This presents a content block that can be reprented by a single html block type element.
     * In most cases, it corresponds to an HTML block level element, i.e. P, DIV, LI, TD etc.
     */
    class NodeBlockElement extends StartEndBlockElement {
        /**
         * Create a new instance of NodeBlockElement class
         * @param containerNode The container DOM Node of this NodeBlockElement
         */
        constructor(containerNode: Node);
        /**
         * Gets first inline
         */
        getFirstInlineElement(): InlineElement;
        /**
         * Gets last inline
         */
        getLastInlineElement(): InlineElement;
        contains(arg: InlineElement | Node): boolean;
    }

    /**
     * This reprents a block that is identified by a start and end node
     * This is for cases like <ced>Hello<BR>World</ced>
     * in that case, Hello<BR> is a block, World is another block
     * Such block cannot be represented by a NodeBlockElement since they don't chained up
     * to a single parent node, instead they have a start and end
     * This start and end must be in same sibling level and have same parent in DOM tree
     */
    class StartEndBlockElement implements BlockElement {
        private startNode;
        private endNode;
        protected firstInline: InlineElement;
        protected lastInline: InlineElement;
        /**
         * Create a new instance of StartEndBlockElement class
         * @param rootNode rootNode of current scope
         * @param startNode startNode of this block element
         * @param endNode end nod of this block element
         */
        constructor(startNode: Node, endNode: Node);
        /**
         * Gets the text content
         */
        getTextContent(): string;
        /**
         * Get all nodes represented in a Node array
         * This only works for balanced node -- start and end is at same level
         */
        getContentNodes(): Node[];
        /**
         * Gets the start node
         */
        getStartNode(): Node;
        /**
         * Gets the end node
         */
        getEndNode(): Node;
        /**
         * Gets first inline
         */
        getFirstInlineElement(): InlineElement;
        /**
         * Gets last inline
         */
        getLastInlineElement(): InlineElement;
        /**
         * Checks equals of two blocks
         */
        equals(blockElement: BlockElement): boolean;
        /**
         * Checks if this block element is after another block element
         */
        isAfter(blockElement: BlockElement): boolean;
        /**
         * Checks if an inline falls inside me
         */
        contains(inlineElement: InlineElement): boolean;
        /**
         * Checks if an Html node is contained within the block
         */
        contains(node: Node): boolean;
    }

    /**
     * This produces a block element from a a node
     * It needs to account for various HTML structure. Examples:
     * 1) <ced><div>abc</div></ced>
     *   This is most common the case, user passes in a node pointing to abc, and get back a block representing <div>abc</div>
     * 2) <ced><p><br></p></ced>
     *   Common content for empty block, user passes node pointing to <br>, and get back a block representing <p><br></p>
     * 3) <ced>abc</ced>
     *   Not common, but does happen. It is still a block in user's view. User passes in abc, and get back a start-end block representing abc
     *   NOTE: abc could be just one node. However, since it is not a html block, it is more appropriate to use start-end block although they point to same node
     * 4) <ced><div>abc<br>123</div></ced>
     *   A bit tricky, but can happen when user use Ctrl+Enter which simply inserts a <BR> to create a link break. There're two blocks:
     *   block1: 1) abc<br> block2: 123
     * 5) <ced><div>abc<div>123</div></div></ced>
     *   Nesting div and there is text node in same level as a DIV. Two blocks: 1) abc 2) <div>123</div>
     * 6) <ced><div>abc<span>123<br>456</span></div></ced>
     *   This is really tricky. Essentially there is a <BR> in middle of a span breaking the span into two blocks;
     *   block1: abc<span>123<br> block2: 456
     * In summary, given any arbitary node (leaf), to identify the head and tail of the block, following rules need to be followed:
     * 1) to identify the head, it needs to crawl DOM tre left/up till a block node or BR is encountered
     * 2) same for identifying tail
     * 3) should also apply a block ceiling, meaning as it crawls up, it should stop at a block node
     */
    function getBlockElementAtNode(rootNode: Node, node: Node): BlockElement;

    /**
     * Get next block
     */
    function getNextBlockElement(rootNode: Node, blockElement: BlockElement): BlockElement;

    /**
     * Get previous block
     */
    function getPreviousBlockElement(rootNode: Node, blockElement: BlockElement): BlockElement;

    interface TraversingScoper {
        getStartBlockElement: () => BlockElement;
        getStartInlineElement: () => InlineElement;
        getInlineElementBeforeStart?: () => InlineElement;
        getInlineElementAfterStart?: () => InlineElement;
        isBlockInScope: (blockElement: BlockElement) => boolean;
        trimInlineElement: (inlineElement: InlineElement) => InlineElement;
    }

    class ContentTraverser {
        private rootNode;
        private scoper;
        private currentInline;
        private currentBlock;
        constructor(rootNode: Node, scoper: TraversingScoper);
        readonly currentBlockElement: BlockElement;
        getNextBlockElement(): BlockElement;
        getPreviousBlockElement(): BlockElement;
        readonly currentInlineElement: InlineElement;
        getNextInlineElement(): InlineElement;
        getPreviousInlineElement(): InlineElement;
    }

    class BodyScoper implements TraversingScoper {
        private rootNode;
        constructor(rootNode: Node);
        getStartBlockElement(): BlockElement;
        getStartInlineElement(): InlineElement;
        isBlockInScope(blockElement: BlockElement): boolean;
        trimInlineElement(inlineElement: InlineElement): InlineElement;
    }

    class SelectionBlockScoper implements TraversingScoper {
        private startPosition;
        private readonly editorSelection;
        private selectionBlock;
        constructor(rootNode: Node, selectionRange: SelectionRange, startPosition: ContentPosition);
        getStartBlockElement(): BlockElement;
        getStartInlineElement(): InlineElement;
        getInlineElementBeforeStart(): InlineElement;
        isBlockInScope(blockElement: BlockElement): boolean;
        trimInlineElement(inlineElement: InlineElement): InlineElement;
    }

    class SelectionScoper implements TraversingScoper {
        private readonly editorSelection;
        constructor(rootNode: Node, selectionRange: SelectionRange);
        getStartBlockElement(): BlockElement;
        getStartInlineElement(): InlineElement;
        isBlockInScope(blockElement: BlockElement): boolean;
        trimInlineElement(inlineElement: InlineElement): InlineElement;
    }

    class VTable {
        table: HTMLTableElement;
        cells: VCell[][];
        row: number;
        col: number;
        private trs;
        constructor(node: HTMLTableElement | HTMLTableCellElement);
        writeBack(): void;
        applyFormat(format: TableFormat): void;
        forEachCellOfCurrentColumn(callback: (cell: VCell, row: VCell[], i: number) => void): void;
        forEachCellOfCurrentRow(callback: (cell: VCell, i: number) => void): void;
        getCell(row: number, col: number): VCell;
        getCurrentTd(): HTMLTableCellElement;
        static moveChildren(fromNode: Node, toNode?: Node): void;
        static cloneNode<T extends Node>(node: T): T;
        static cloneCell(cell: VCell): VCell;
        private recalcSpans(row, col);
    }

    interface VCell {
        td?: HTMLTableCellElement;
        spanLeft?: boolean;
        spanAbove?: boolean;
    }

    function applyFormat(element: HTMLElement, format: DefaultFormat): void;

    function changeElementTag(element: HTMLElement, newTag: string, range?: Range): HTMLElement;

    function contains(container: Node, contained: Node, treatSameNodeAsContain?: boolean): boolean;

    /**
     * Sanitize HTML string
     * This function will do the following work:
     * 1. Convert global CSS into inline CSS
     * 2. Remove dangerous HTML tags and attributes
     * 3. Remove useless CSS properties
     * @param html The input HTML
     * @param additionalStyleNodes additional style nodes for inline css converting
     * @param convertInlineCssOnly Whether only convert inline css and skip html content sanitizing
     * @param propertyCallbacks A callback function map to handle HTML properties
     */
    function sanitizeHtml(html: string, additionalStyleNodes?: HTMLStyleElement[], convertInlineCssOnly?: boolean, propertyCallbacks?: SanitizeHtmlPropertyCallback, currentStyle?: StyleMap): string;

    type SanitizeHtmlPropertyCallback = {
        [name: string]: (value: string) => string;
    };

    type StyleMap = {
        [name: string]: string;
    };

    function fromHtml(htmlFragment: string, ownerDocument: HTMLDocument): Node[];

    function getComputedStyle(node: Node, styleNames?: string | string[]): string[];

    function getTagOfNode(node: Node): string;

    function intersectWithNodeRange(node: Node, start: Node, end: Node, containOnly: boolean): boolean;

    function isBlockElement(node: Node): boolean;

    /**
     * Check if position is or encompasses any of targets
     * @param position The doucment position to check
     * @param targets The target position or position array
     */
    function isDocumentPosition(position: DocumentPosition, targets: DocumentPosition | DocumentPosition[]): boolean;

    /**
     * Check if a given node has visible content
     */
    function isNodeEmpty(node: Node, trim?: boolean): boolean;

    /**
     * Split parent node of the given node before/after the given node.
     * When a parent node contains [A,B,C] and pass B as the given node,
     * If split before, the new nodes will be [A][B,C] and returns [A];
     * otherwise, it will be [A,B][C] and returns [C].
     * @param node The node to split before/after
     * @param splitBefore Whether split before or after
     * @returns The new parent node
     */
    function splitParentNode(node: Node, splitBefore: boolean): Node;

    /**
     * Convert plain to HTML
     * @param text The plain text to convert
     * @returns HTML string to present the input text
     */
    function textToHtml(text: string): string;

    function unwrap(node: Node): Node;

    function wrap(node: Node, htmlFragment: string): Node;

    function wrapAll(nodes: Node[], htmlFragment?: string): Node;

    class Editor {
        private omitContentEditable;
        private disableRestoreSelectionOnFocus;
        private inIME;
        private core;
        private eventDisposers;
        private defaultRange;
        /**
         * Creates an instance of Editor
         * @param contentDiv The DIV HTML element which will be the container element of editor
         * @param options An optional options object to customize the editor
         */
        constructor(contentDiv: HTMLDivElement, options?: EditorOptions);
        /**
         * Dispose this editor, dispose all plugins and custom data
         */
        dispose(): void;
        /**
         * Get whether this editor is disposed
         * @returns True if editor is disposed, otherwise false
         */
        isDisposed(): boolean;
        /**
         * Insert node into editor
         * @param node The node to insert
         * @param option Insert options. Default value is:
         *  position: ContentPosition.SelectionStart
         *  updateCursor: true
         *  replaceSelection: true
         *  insertOnNewLine: false
         * @returns true if node is inserted. Otherwise false
         */
        insertNode(node: Node, option?: InsertOption): boolean;
        /**
         * Delete a node from editor content
         * @param node The node to delete
         * @returns true if node is deleted. Otherwise false
         */
        deleteNode(node: Node): boolean;
        /**
         * Replace a node in editor content with another node
         * @param existingNode The existing node to be replaced
         * @param new node to replace to
         * @returns true if node is replaced. Otherwise false
         */
        replaceNode(existingNode: Node, toNode: Node): boolean;
        /**
         * Get BlockElement at given node
         * @param node The node to create InlineElement
         * @requires The BlockElement result
         */
        getBlockElementAtNode(node: Node): BlockElement;
        /**
         * Check if the node falls in the editor content
         * @param node The node to check
         * @returns True if the given node is in editor content, otherwise false
         */
        contains(node: Node): boolean;
        /**
         * Check whether the editor contains any visible content
         * @param trim Whether trime the content string before check. Default is false
         * @returns True if there's no visible content, otherwise false
         */
        isEmpty(trim?: boolean): boolean;
        /**
         * Get current editor content as HTML string
         * @param triggerExtractContentEvent Whether trigger ExtractContent event to all plugins
         * before return. Use this parameter to remove any temporary content added by plugins.
         * @returns HTML string representing current editor content
         */
        getContent(triggerExtractContentEvent?: boolean): string;
        /**
         * Get plain text content inside editor
         * @returns The text content inside editor
         */
        getTextContent(): string;
        /**
         * Set HTML content to this editor. All existing content will be replaced. A ContentChanged event will be triggered
         * @param content HTML content to set in
         */
        setContent(content: string): void;
        /**
         * Insert HTML content into editor
         * @param HTML content to insert
         * @param option Insert options. Default value is:
         *  position: ContentPosition.SelectionStart
         *  updateCursor: true
         *  replaceSelection: true
         *  insertOnNewLine: false
         */
        insertContent(content: string, option?: InsertOption): void;
        /**
         * DOM query nodes in editor
         * @param selector Selector string to query
         * @returns Node list of the query result
         */
        queryNodes(selector: string): Node[];
        getSelectionRange(): SelectionRange;
        /**
         * Check if focus is in editor now
         * @returns true if focus is in editor, otherwise false
         */
        hasFocus(): boolean;
        /**
         * Focus to this editor, the selection was restored to where it was before, no unexpected scroll.
         */
        focus(): void;
        /**
         * Select content by range
         * @param range The range to select
         * @returns True if content is selected, otherwise false
         */
        select(range: Range): boolean;
        /**
         * Select content by SelectionRange
         * @param range The SelectionRange object which represents the content range to select
         * @returns True if content is selected, otherwise false
         */
        select(range: SelectionRange): boolean;
        /**
         * Select content by Position and collapse to this position
         * @param position The position to select
         * @returns True if content is selected, otherwise false
         */
        select(position: Position): boolean;
        /**
         * Select content by a start and end position
         * @param start The start position to select
         * @param end The end position to select, if this is the same with start, the selection will be collapsed
         * @returns True if content is selected, otherwise false
         */
        select(start: Position, end: Position): boolean;
        /**
         * Select content by node
         * @param node The node to select
         * @returns True if content is selected, otherwise false
         */
        select(node: Node): boolean;
        /**
         * Select content by node and offset, and collapse to this position
         * @param node The node to select
         * @param offset The offset of node to select, can be a number or value of PositionType
         * @returns True if content is selected, otherwise false
         */
        select(node: Node, offset: number | PositionType): boolean;
        /**
         * Select content by start and end nodes and offsets
         * @param startNode The node to select start from
         * @param startOffset The offset to select start from
         * @param endNode The node to select end to
         * @param endOffset The offset to select end to
         * @returns True if content is selected, otherwise false
         */
        select(startNode: Node, startOffset: number | PositionType, endNode: Node, endOffset: number | PositionType): boolean;
        /**
         * Add a custom DOM event handler to handle events not handled by roosterjs.
         * Caller need to take the responsibility to dispose the handler properly
         * @param eventName DOM event name to handle
         * @param handler Handler callback
         * @returns A dispose function. Call the function to dispose this event handler
         */
        addDomEventHandler(eventName: string, handler: (event: UIEvent) => void): () => void;
        /**
         * Trigger an event to be dispatched to all plugins
         * @param pluginEvent The event object to trigger
         * @param broadcast indicates if the event needs to be dispatched to all plugins
         * True means to all, false means to allow exclusive handling from one plugin unless no one wants that
         */
        triggerEvent(pluginEvent: PluginEvent, broadcast?: boolean): void;
        /**
         * Trigger a ContentChangedEvent
         * @param source Source of this event, by default is 'SetContent'
         * @param data additional data for this event
         */
        triggerContentChangedEvent(source?: ChangeSource | string, data?: any): void;
        /**
         * Undo last edit operation
         */
        undo(): void;
        /**
         * Redo next edit operation
         */
        redo(): void;
        /**
         * Add undo snapshot, and execute a format callback function, then add another undo snapshot if
         * addsnapshotAfterFormat is set to true, finally trigger ContentChangedEvent with given change source.
         * If this function is called nested, undo snapshot will only be added in the outside one
         * @param callback The callback function to perform formatting
         * @param preserveSelection Set to true to try preserve the selection after format
         * @param addsnapshotAfterFormat Whether should add an undo snapshot after format callback is called
         * @param changeSource The change source to use when fire ContentChangedEvent. Default value is 'Format'
         * If pass null, the event will not be fired.
         * @param dataCallback A callback function to retrieve the data for ContentChangedEvent
         * @param skipAddingUndoAfterFormat Set to true to only add undo snapshot before format. Default value is false
         */
        formatWithUndo(callback: () => void | Node, preserveSelection?: boolean, changeSource?: ChangeSource | string, dataCallback?: () => any, skipAddingUndoAfterFormat?: boolean): void;
        /**
         * Whether there is an available undo snapshot
         */
        canUndo(): boolean;
        /**
         * Whether there is an available redo snapshot
         */
        canRedo(): boolean;
        /**
         * Get document which contains this editor
         * @returns The HTML document which contains this editor
         */
        getDocument(): Document;
        /**
         * Get custom data related to this editor
         * @param key Key of the custom data
         * @param getter Getter function. If custom data for the given key doesn't exist,
         * call this function to get one and store it.
         * @param disposer An optional disposer function to dispose this custom data when
         * dispose editor.
         */
        getCustomData<T>(key: string, getter: () => T, disposer?: (value: T) => void): T;
        /**
         * Check if editor is in IME input sequence
         * @returns True if editor is in IME input sequence, otherwise false
         */
        isInIME(): boolean;
        /**
         * Get default format of this editor
         * @returns Default format object of this editor
         */
        getDefaultFormat(): DefaultFormat;
        /**
         * Get a content traverser that can be used to travse content within editor
         * @param scope Content scope type. There are 3 kinds of scoper:
         * 1) SelectionBlockScoper is a block based scoper that restrict traversing within the block where the selection is
         *    it allows traversing from start, end or selection start position
         *    this is commonly used to parse content from cursor as user type up to the begin or end of block
         * 2) SelectionScoper restricts traversing within the selection. It is commonly used for applying style to selection
         * 3) BodyScoper will traverse the entire editor body from the beginning (ignoring the passed in position parameter)
         * @param position Start position of the traverser
         * @returns A content traverser to help travse among InlineElemnt/BlockElement within scope
         */
        getContentTraverser(scope: ContentScope, position?: ContentPosition): ContentTraverser;
        private createEventHandlers();
        private onKeyPress;
        private ensureInitialContent(initialContent);
        private createDefaultRange();
    }

    interface EditorOptions {
        plugins?: EditorPlugin[];
        defaultFormat?: DefaultFormat;
        undo?: UndoService;
        initialContent?: string;
        disableRestoreSelectionOnFocus?: boolean;
        omitContentEditableAttributeChanges?: boolean;
    }

    interface EditorPlugin {
        initialize: (editor: Editor) => void;
        dispose: () => void;
        willHandleEventExclusively?: (event: PluginEvent) => boolean;
        onPluginEvent?: (event: PluginEvent) => void;
    }

    /**
     * Provides snapshot based undo service for Editor
     */
    class Undo implements UndoService {
        private preserveSnapshots;
        private editor;
        private isRestoring;
        private hasNewContent;
        private undoSnapshots;
        private lastKeyPress;
        private onDropDisposer;
        /**
         * Create an instance of Undo
         * @param preserveSnapshots True to preserve the snapshots after dispose, this allows
         * this object to be reused when editor is disposed and created again
         */
        constructor(preserveSnapshots?: boolean);
        /**
         * Initialize this plugin. This should only be called from Editor
         * @param editor Editor instance
         */
        initialize(editor: Editor): void;
        /**
         * Dispose this plugin
         */
        dispose(): void;
        /**
         * Handle events triggered from editor
         * @param event PluginEvent object
         */
        onPluginEvent(event: PluginEvent): void;
        /**
         * Clear all existing undo snapshots
         */
        clear(): void;
        /**
         * Restore an undo snapshot to editor
         */
        undo(): void;
        /**
         * Restore a redo snapshot to editor
         */
        redo(): void;
        /**
         * Whether there is a snapshot for undo
         */
        canUndo(): boolean;
        /**
         * Whether there is a snapshot for redo
         */
        canRedo(): boolean;
        /**
         * Add an undo snapshot
         */
        addUndoSnapshot(): void;
        private restoreSnapshot(delta);
        private onKeyDown(pluginEvent);
        private onKeyPress(pluginEvent);
        private clearRedoForInput();
        private getSnapshotsManager();
    }

    interface UndoService extends EditorPlugin {
        undo: () => void;
        redo: () => void;
        addUndoSnapshot: () => void;
        canUndo: () => boolean;
        canRedo: () => boolean;
        clear: () => void;
    }

    const browserData: BrowserData;

    interface BrowserData {
        isMac: boolean;
        isWin: boolean;
        isWebKit: boolean;
        isIE: boolean;
        isIE11OrGreater: boolean;
        isSafari: boolean;
        isChrome: boolean;
        isFirefox: boolean;
        isEdge: boolean;
    }

    function clearEventDataCache(event: PluginEvent, key: string): void;

    function cacheGetEventData<T>(event: PluginEvent, key: string, getter: () => T): T;

    function buildSnapshot(editor: Editor): string;

    function restoreSnapshot(editor: Editor, snapshot: string): void;

    /**
     * Read CursorData from plugin event cache. If not, create one
     * @param event The plugin event, it stores the event cached data for looking up.
     * If passed as null, we will create a new cursor data
     * @param editor The editor instance
     * @returns The cursor data
     */
    function cacheGetCursorEventData(event: PluginEvent, editor: Editor): CursorData;

    /**
     * Clear the cursor data in a plugin event.
     * This is called when the cursor data is changed, e.g, the text is replace with HyperLink
     * @param event The plugin event
     */
    function clearCursorEventDataCache(event: PluginEvent): void;

    class CursorData {
        private editor;
        private cachedTextBeforeCursor;
        private cachedWordBeforeCursor;
        private inlineBeforeCursor;
        private inlineAfterCursor;
        private backwardTraverser;
        private forwardTraverser;
        private backwardTraversingComplete;
        private forwardTraversingComplete;
        private inlineElementsBeforeCursor;
        private firstNonTextInlineBeforeCursor;
        /**
         * Create a new CursorData instance
         * @param editor The editor instance
         */
        constructor(editor: Editor);
        /**
         * Get the word before cursor. The word is determined by scanning backwards till the first white space, the portion
         * between cursor and the white space is the word before cursor
         * @returns The word before cursor
         */
        readonly wordBeforeCursor: string;
        /**
         * Get the inline element before cursor
         * @returns The inlineElement before cursor
         */
        readonly inlineElementBeforeCursor: InlineElement;
        /**
         * Get the inline element after cursor
         * @returns The inline element after cursor
         */
        readonly inlineElementAfterCursor: InlineElement;
        /**
         * Get X number of chars before cursor
         * The actual returned chars may be less than what is requested. e.g, length of text before cursor is less then X
         * @param numChars The X number of chars user want to get
         * @returns The actual chars we get as a string
         */
        getXCharsBeforeCursor(numChars: number): string;
        /**
         * Get text section before cursor till stop condition is met.
         * This offers consumers to retrieve text section by section
         * The section essentially is just an inline element which has Container element
         * so that the consumer can remember it for anchoring popup or verification purpose
         * when cursor moves out of context etc.
         * @param stopFunc The callback stop function
         */
        getTextSectionBeforeCursorTill(stopFunc: (textInlineElement: InlineElement) => boolean): void;
        /**
         * Get first non textual inline element before cursor
         * @returns First non textutal inline element before cursor or null if no such element exists
         */
        getFirstNonTextInlineBeforeCursor(): InlineElement;
        private continueTraversingBackwardTill(stopFunc);
    }

    /**
     * Returns a rect representing the location of the cursor.
     * In case there is a uncollapsed selection witin editor, this returns
     * the position for focus node.
     * The returned rect structure has a left and right and they should be same
     * here since it is for cursor, not for a range.
     */
    function getCursorRect(editor: Editor): Rect;

    /**
     * Get the node at selection. If an expectedTag is specified, return the nearest ancestor of current node
     * which matches the tag name, or null if no match found in editor.
     * @param editor The editor instance
     * @param expectedTag The expected tag name. If null, return the element at cursor
     * @param startNode If specified, use this node as start node to search instead of current node
     * @returns The node at cursor or the nearest ancestor with the tag name is specified
     */
    function getNodeAtCursor(editor: Editor, expectedTag?: string, startNode?: Node): Node;

    /**
     * Get the node at selection from event cache if it exists.
     * If an expectedTag is specified, return the nearest ancestor of current node
     * which matches the tag name, or null if no match found in editor.
     * @param editor The editor instance
     * @param event Event object to get cached object from
     * @param expectedTag The expected tag name. If null, return the element at cursor
     * @returns The element at cursor or the nearest ancestor with the tag name is specified
     */
    function cacheGetNodeAtCursor(editor: Editor, event: PluginEvent, expectedTag: string): Node;

    /**
     * Query nodes intersected with current selection using a selector
     * @param editor The editor
     * @param selector The selector to query
     * @returns The nodes intersected with current selection, returns an empty array if no result is found
     */
    function queryNodesWithSelection(editor: Editor, selector: string): Node[];

    /**
     * Replace the specified range with a node
     * @param editor The editor instance
     * @param range The range in which content needs to be replaced
     * @param node The node to be inserted
     * @param exactMatch exactMatch is to match exactly, i.e.
     * In auto linkification, users could type URL followed by some punctuation and hit space. The auto link will kick in on space,
     * at the moment, what is before cursor could be "<URL>,", however, only "<URL>" makes the link. by setting exactMatch = false, it does not match
     * from right before cursor, but can scan through till first same char is seen. On the other hand if set exactMatch = true, it starts the match right
     * before cursor.
     * @returns True if we complete the replacement, false otherwise
     */
    function replaceRangeWithNode(editor: Editor, range: Range, node: Node, exactMatch: boolean): boolean;

    /**
     * Replace text before cursor with a node
     * @param editor The editor instance
     * @param text The text for matching. We will try to match the text with the text before cursor
     * @param node The node to replace the text with
     * @param exactMatch exactMatch is to match exactly, i.e.
     * In auto linkification, users could type URL followed by some punctuation and hit space. The auto link will kick in on space,
     * at the moment, what is before cursor could be "<URL>,", however, only "<URL>" makes the link. by setting exactMatch = false, it does not match
     * from right before cursor, but can scan through till first same char is seen. On the other hand if set exactMatch = true, it starts the match right
     * before cursor.
     * @param cursorData
     */
    function replaceTextBeforeCursorWithNode(editor: Editor, text: string, node: Node, exactMatch: boolean, cursorData?: CursorData): boolean;

    /**
     * Validate the text matches what's before the cursor, and return the range for it
     * @param editor The editor instance
     * @param text The text to match against
     * @param exactMatch Whether it is an exact match
     * @param cursorData The cursor data
     * @returns The range for the matched text, null if unable to find a match
     */
    function validateAndGetRangeForTextBeforeCursor(editor: Editor, text: string, exactMatch: boolean, cursorData: CursorData): Range;

    /**
     * Get the list state at selection
     * The list state refers to the HTML elements <OL> or <UL>
     * @param editor The editor instance
     * @param event (Optional) The plugin event, it stores the event cached data for looking up.
     * If not passed, we will query the first <LI> node in selection and return the list state of its direct parent
     * @returns The list state. ListState.Numbering indicates <OL>, ListState.Bullets indicates <UL>,
     * ListState.None indicates no <OL> or <UL> elements found at current selection
     */
    function cacheGetListState(editor: Editor, event?: PluginEvent): ListState;

    /**
     * Clear the format in current selection, after cleaning, the format will be
     * changed to default format. The format that get cleaned include B/I/U/font name/
     * font size/text color/background color/align left/align right/align center/superscript/subscript
     * @param editor The editor instance
     */
    function clearFormat(editor: Editor): void;

    /**
     * Insert a hyperlink at cursor.
     * When there is a selection, hyperlink will be applied to the selection,
     * otherwise a hyperlink will be inserted to the cursor position.
     * @param editor Editor object
     * @param link Link address, can be http(s), mailto, notes, file, unc, ftp, news, telnet, gopher, wais.
     * When protocol is not specified, a best matched protocol will be predicted.
     * @param altText Optional alt text of the link, will be shown when hover on the link
     * @param displayText Optional display text for the link.
     * If there is a selection, this parameter will be ignored.
     * If not specified, will use link instead
     */
    function createLink(editor: Editor, link: string, altText?: string, displayText?: string): void;

    /**
     * Get format state at cursor
     * A format state is a collection of all format related states, e.g.,
     * bold, italic, underline, font name, font size, etc.
     * @param editor The editor
     * @param (Optional) The plugin event, it stores the event cached data for looking up.
     * In this function the event cache is used to get list state and header level. If not passed,
     * it will query the node within selection to get the info
     * @returns The format state at cursor
     */
    function getFormatState(editor: Editor, event?: PluginEvent): FormatState;

    /**
     * Insert an image to editor at current selection
     * @param editor The editor instance
     * @param imageFile The image file. There are at least 3 ways to obtain the file object:
     * From local file, from clipboard data, from drag-and-drop
     */
    function insertImage(editor: Editor, imageFile: File): void;

    /**
     * Insert table into editor at current selection
     * @param editor The editor instance
     * @param columns Number of columns in table, it also controls the default table cell width:
     * if columns <= 4, width = 120px; if columns <= 6, width = 100px; else width = 70px
     * @param rows Number of rows in table
     * @param format (Optional) The table format. If not passed, the default format will be applied:
     * background color: #FFF; border color: #ABABAB
     */
    function insertTable(editor: Editor, columns: number, rows: number, format?: TableFormat): void;

    /**
     * Edit table with given operation. If there is no table at cursor then no op.
     * @param editor The editor instance
     * @param operation Table operation
     */
    function editTable(editor: Editor, operation: TableOperation): void;

    /**
     * Format table
     * @param table The table to format
     * @param formatName Name of the format to use
     */
    function formatTable(editor: Editor, format: TableFormat, table?: HTMLTableElement): void;

    /**
     * Remove link at selection. If no links at selection, do nothing.
     * If selection contains multiple links, all of the link styles will be removed.
     * If only part of a link is selected, the whole link style will be removed.
     * @param editor The editor instance
     */
    function removeLink(editor: Editor): void;

    /**
     * Set content alignment
     * @param editor The editor instance
     * @param alignment The alignment option:
     * Alignment.Center, Alignment.Left, Alignment.Right
     */
    function setAlignment(editor: Editor, alignment: Alignment): void;

    /**
     * Set background color at current selection
     * @param editor The editor instance
     * @param color The color string, can be any of the predefined color names (e.g, 'red')
     * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.
     * Currently there's no validation to the string, if the passed string is invalid, it won't take affect
     */
    function setBackgroundColor(editor: Editor, color: string): void;

    /**
     * Set text color at selection
     * @param editor The editor instance
     * @param color The color string, can be any of the predefined color names (e.g, 'red')
     * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.
     * Currently there's no validation to the string, if the passed string is invalid, it won't take affect
     */
    function setTextColor(editor: Editor, color: string): void;

    /**
     * Change direction for the blocks/paragraph at selection
     * @param editor The editor instance
     * @param dir The direction option:
     * Direction.LeftToRight refers to 'ltr', Direction.RightToLeft refers to 'rtl'
     */
    function setDirection(editor: Editor, dir: Direction): void;

    /**
     * Set font name at selection
     * @param editor The editor instance
     * @param fontName The fontName string, should be a valid CSS font-family style.
     * Currently there's no validation to the string, if the passed string is invalid, it won't take affect
     */
    function setFontName(editor: Editor, fontName: string): void;

    /**
     * Set font size at selection
     * @param editor The editor instance
     * @param fontSize The fontSize string, should be a valid CSS font-size style.
     * Currently there's no validation to the string, if the passed string is invalid, it won't take affect
     */
    function setFontSize(editor: Editor, fontSize: string): void;

    /**
     * Set image alt text for all selected images at selection. If no images is contained
     * in selection, do nothing.
     * The alt attribute provides alternative information for an image if a user for some reason
     * cannot view it (because of slow connection, an error in the src attribute, or if the user
     * uses a screen reader). See https: * @param editor The editor instance
     * @param altText The image alt text
     */
    function setImageAltText(editor: Editor, altText: string): void;

    /**
     * Set indentation at selection
     * If selection contains bullet/numbering list, increase/decrease indentation will
     * increase/decrease the list level by one.
     * @param editor The editor instance
     * @param indentation The indentation option:
     * Indentation.Increase to increase indentation or Indentation.Decrease to decrease indentation
     */
    function setIndentation(editor: Editor, indentation: Indentation): void;

    /**
     * Toggle bold at selection
     * If selection is collapsed, it will only affect the following input after caret
     * If selection contains only bold text, the bold style will be removed
     * If selection contains only normal text, bold style will be added to the whole selected text
     * If selection contains both bold and normal text, bold stle will be added to the whole selected text
     * @param editor The editor instance
     */
    function toggleBold(editor: Editor): void;

    /**
     * Toggle bullet at selection
     * If selection contains bullet in deep level, toggle bullet will decrease the bullet level by one
     * If selection contains number list, toggle bullet will convert the number list into bullet list
     * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding
     * browser execCommand API
     * @param editor The editor instance
     */
    function toggleBullet(editor: Editor): void;

    /**
     * Toggle italic at selection
     * If selection is collapsed, it will only affect the input after caret
     * If selection contains only italic text, the italic style will be removed
     * If selection contains only normal text, italic style will be added to the whole selected text
     * If selection contains both italic and normal text, italic stlye will be added to the whole selected text
     * @param editor The editor instance
     */
    function toggleItalic(editor: Editor): void;

    /**
     * Toggle numbering at selection
     * If selection contains numbering in deep level, toggle numbering will decrease the numbering level by one
     * If selection contains bullet list, toggle numbering will convert the bullet list into number list
     * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding
     * realization of browser execCommand API
     * @param editor The editor instance
     */
    function toggleNumbering(editor: Editor): void;

    /**
     * Toggle blockquote at selection, if selection already contains any blockquoted elements,
     * the blockquoted elements will be unblockquoted and other elements will take no affect
     * @param editor The editor instance
     * @param styler (Optional) The custom styler for setting the style for the
     * blockquote element
     */
    function toggleBlockQuote(editor: Editor, styler?: (element: HTMLElement) => void): void;

    /**
     * Toggle strikethrough at selection
     * If selection is collapsed, it will only affect the input after caret
     * If selection contains only strikethrough text, the strikethrough style will be removed
     * If selection contains only normal text, strikethrough style will be added to the whole selected text
     * If selection contains both strikethrough and normal text, strikethrough stlye will be added to the whole selected text
     * @param editor The editor instance
     */
    function toggleStrikethrough(editor: Editor): void;

    /**
     * Toggle subscript at selection
     * If selection is collapsed, it will only affect the input after caret
     * If selection contains only subscript text, the subscript style will be removed
     * If selection contains only normal text, subscript style will be added to the whole selected text
     * If selection contains both subscript and normal text, the subscript style will be removed from whole selected text
     * If selection contains any superscript text, the behavior is determined by corresponding realization of browser
     * execCommand API
     * @param editor The editor instance
     */
    function toggleSubscript(editor: Editor): void;

    /**
     * Toggle superscript at selection
     * If selection is collapsed, it will only affect the input after caret
     * If selection contains only superscript text, the superscript style will be removed
     * If selection contains only normal text, superscript style will be added to the whole selected text
     * If selection contains both superscript and normal text, the superscript style will be removed from whole selected text
     * If selection contains any subscript text, the behavior is determined by corresponding realization of browser
     * execCommand API
     * @param editor The editor instance
     */
    function toggleSuperscript(editor: Editor): void;

    /**
     * Toggle underline at selection
     * If selection is collapsed, it will only affect the input after caret
     * If selection contains only underlined text, the underline style will be removed
     * If selection contains only normal text, underline style will be added to the whole selected text
     * If selection contains both underlined and normal text, the underline style will be added to the whole selected text
     * @param editor The editor instance
     */
    function toggleUnderline(editor: Editor): void;

    /**
     * Toggle header at selection
     * @param editor The editor instance
     * @param level The header level, can be a number from 0 to 6, in which 1 ~ 6 refers to
     * the HTML header element <H1> to <H6>, 0 means no header
     * if passed in param is outside the range, will be rounded to nearest number in the range
     */
    function toggleHeader(editor: Editor, level: number): void;

    /**
     * Try to match a given string with link match rules, return matched link
     * @param url Input url to match
     * @param option Link match option, exact or partial. If it is exact match, we need
     * to check the length of matched link and url
     * @param rules Optional link match rules, if not passed, only the default link match
     * rules will be applied
     * @returns The matched link data, or null if no match found.
     * The link data includes an original url and a normalized url
     */
    function matchLink(url: string): LinkData;

    class DefaultShortcut implements EditorPlugin {
        private editor;
        initialize(editor: Editor): void;
        dispose(): void;
        willHandleEventExclusively(event: PluginEvent): boolean;
        onPluginEvent(event: PluginEvent): void;
    }

    /**
     * An editor plugin that auto linkify text as users type and show a tooltip for existing link
     */
    class HyperLink implements EditorPlugin {
        private getTooltipCallback;
        private target;
        private editor;
        /**
         * Create a new instance of HyperLink class
         * @param getTooltipCallback A callback function to get tooltip text for an existing hyperlink.
         * Default value is to return the href itself. If null, there will be no tooltip text.
         * @param target (Optional) Target window name for hyperlink. If null, will use "_blank"
         * @param linkMatchRules (Optional) Rules for matching hyperlink. If null, will use defaultLinkMatchRules
         */
        constructor(getTooltipCallback?: (href: string) => string, target?: string);
        initialize(editor: Editor): void;
        dispose(): void;
        onPluginEvent(event: PluginEvent): void;
        private resetAnchor(a);
        private autoLink(event);
        private processLink(a);
        private removeTempTooltip(content);
        private onClickLink;
        private tryGetHref(element);
        private forEachHyperLink(callback);
    }

    /**
     * An editor plugin to handle content edit event.
     * The following cases are included:
     * 1. Auto increase/decrease indentation on Tab, Shift+tab
     * 2. Enter, Backspace on empty list item
     * 3. Enter, Backspace on empty blockquote line
     */
    class ContentEdit implements EditorPlugin {
        private features;
        private editor;
        /**
         * Create instance of ContentEdit plugin
         * @param features An optional feature set to determine which features the plugin should provide
         */
        constructor(features?: ContentEditFeatures);
        initialize(editor: Editor): void;
        dispose(): void;
        willHandleEventExclusively(event: PluginEvent): boolean;
        onPluginEvent(event: PluginEvent): void;
        private isListEvent(event, interestedKeyCodes);
        private isTabInTable(event);
        private cacheGetTd(event);
        private getBlockQuoteElementFromEvent(event, keyboardEvent);
        private shouldToggleState(event, node);
        private toggleList(event);
        private isCursorAtBeginningOf(node);
    }

    /**
     * Paste plugin, handles onPaste event and paste content into editor
     */
    class Paste implements EditorPlugin {
        private useDirectPaste;
        private htmlPropertyCallbacks;
        private editor;
        private pasteDisposer;
        /**
         * Create an instance of Paste
         * @param useDirectPaste: This is a test parameter and may be removed in the future.
         * When set to true, we retrieve HTML from clipboard directly rather than using a hidden pasting DIV,
         * then filter out unsafe HTML tags and attributes. Although we removed some unsafe tags such as SCRIPT,
         * OBJECT, ... But there is still risk to have other kinds of XSS scripts embeded. So please do NOT use
         * this parameter if you don't have other XSS detecting logic outside the edtior.
         */
        constructor(useDirectPaste?: boolean, htmlPropertyCallbacks?: SanitizeHtmlPropertyCallback);
        initialize(editor: Editor): void;
        dispose(): void;
        onPluginEvent(event: PluginEvent): void;
        private onPaste;
        /**
         * Paste into editor using passed in clipboardData with original format
         * @param clipboardData The clipboardData to paste
         */
        pasteOriginal(clipboardData: ClipboardData): void;
        /**
         * Paste plain text into editor using passed in clipboardData
         * @param clipboardData The clipboardData to paste
         */
        pasteText(clipboardData: ClipboardData): void;
        /**
         * Paste into editor using passed in clipboardData with curent format
         * @param clipboardData The clipboardData to paste
         */
        pasteAndMergeFormat(clipboardData: ClipboardData): void;
        private detectPasteOption(clipboardData);
        private paste(clipboardData, pasteOption, mergeCurrentFormat?);
        private internalPaste(event);
        private applyTextFormat(node, format);
    }

    /**
     * Feature set for ContentEdit plugin.
     * Call getDefaultContentEditFeatures() to get default feature set.
     */
    interface ContentEditFeatures {
        /**
         * When press Tab in a list, indent current list item
         * @default true
         */
        indentWhenTab: boolean;
        /**
         * When press Shift+Tab in a list, outdent current list item
         * @default true
         */
        outdentWhenShiftTab: boolean;
        /**
         * When press BaskSpace on empty line which is the first item of a list, outdent current list item
         * @default true
         */
        outdentWhenBackspaceOnEmptyFirstLine: boolean;
        /**
         * When press Enter on empty line in a list, outdent current list item
         * @default true
         */
        outdentWhenEnterOnEmptyLine: boolean;
        /**
         * When press Backspace on first char in a list, make current item a new line of previous list item
         * @default false
         */
        mergeInNewLineWhenBackspaceOnFirstChar: boolean;
        /**
         * When press BAckspace on empty line which is the first line of a blockquote, unquote current line
         * @default true
         */
        unquoteWhenBackspaceOnEmptyFirstLine: boolean;
        /**
         * When press Enter on empty line in a blockquote, unquote current line
         * @default true
         */
        unquoteWhenEnterOnEmptyLine: boolean;
        /**
         * When press space after an asterik or number in an empty line, toggle bullet/numbering
         * @default true
         */
        autoBullet: boolean;
        /**
         * When press TAB or SHIFT+TAB key in table cell, jump to next/previous table cell
         * @default true
         */
        tabInTable: boolean;
    }

    /**
     * Get default feature set of ContentEdit plugin
     */
    function getDefaultContentEditFeatures(): ContentEditFeatures;

    class ImageResize implements EditorPlugin {
        private minWidth;
        private minHeight;
        private selectionBorderColor;
        private forcePreserveRatio;
        private editor;
        private startPageX;
        private startPageY;
        private startWidth;
        private startHeight;
        private resizeDiv;
        private direction;
        /**
         * Create a new instance of ImageResize
         * @param minWidth Minimum width of image when resize in pixel, default value is 10
         * @param minHeight Minimum height of image when resize in pixel, default value is 10
         * @param selectionBorderColor Color of resize border and handles, default value is #DB626C
         * @param forcePreserveRatio Whether always preserve width/height ratio when resize, default value is false
         */
        constructor(minWidth?: number, minHeight?: number, selectionBorderColor?: string, forcePreserveRatio?: boolean);
        initialize(editor: Editor): void;
        dispose(): void;
        onPluginEvent(e: PluginEvent): void;
        private select(target);
        private unselect(selectImageAfterUnselect);
        private startResize;
        private doResize;
        private finishResize;
        private createResizeDiv(target);
        private removeResizeDiv;
        private extractHtml(html);
        private getSelectedImage();
        private isNorth(direction);
        private isWest(direction);
    }

    class TableResize implements EditorPlugin {
        private editor;
        private onMouseOverDisposer;
        private td;
        private pageX;
        private initialPageX;
        constructor(isRtl?: boolean);
        initialize(editor: Editor): void;
        dispose(): void;
        onPluginEvent(event: PluginEvent): void;
        private clickIntoCurrentTd(event);
        private onMouseOver;
        private calcAndShowHandle();
        private adjustHandle(pageX);
        private getPosition(e);
        private getResizeHandle();
        private cancelEvent(e);
        private onMouseDown;
        private onMouseMove;
        private onMouseUp;
        private setTableColumnWidth(width);
        private isRtl(element);
    }

    /**
     * A watermark plugin to manage watermark string for roosterjs
     */
    class Watermark implements EditorPlugin {
        private watermark;
        private format;
        private editor;
        private isWatermarkShowing;
        private focusDisposer;
        private blurDisposer;
        /**
         * Create an instance of Watermark plugin
         * @param watermark The watermark string
         */
        constructor(watermark: string, format?: DefaultFormat);
        initialize(editor: Editor): void;
        dispose(): void;
        onPluginEvent(event: PluginEvent): void;
        private handleWatermark;
        private showHideWatermark(ignoreCachedState);
        private showWatermark();
        private hideWatermark();
        private removeWartermarkFromHtml(event);
    }

}