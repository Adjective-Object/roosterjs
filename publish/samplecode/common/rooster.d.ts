// Type definitions for roosterjs (Version 7.0.0)
// Generated by dts tool from roosterjs
// Project: https://github.com/Microsoft/roosterjs

declare namespace roosterjs {
    /**
     * Create an editor instance with most common options
     * @param contentDiv The html div element needed for creating the editor
     * @param additionalPlugins The additional user defined plugins. Currently the default plugins that are already included are
     * DefalutShortcut, HyperLink, Paste, and ContentEdit, user don't need to add those.
     * @param initialContent The initial content to show in editor. It can't be removed by undo, user need to manually remove it if needed.
     * @returns The editor instance
     */
    function createEditor(contentDiv: HTMLDivElement, additionalPlugins?: EditorPlugin[], initialContent?: string): Editor;

    /**
     * enum for setting block alignment, used by setAlignment API
     */
    const enum Alignment {
        /**
         * Align left
         */
        Left = 0,
        /**
         * Align center
         */
        Center = 1,
        /**
         * Align right
         */
        Right = 2,
    }

    /**
     * enum for setting block direction, used by setDirection API
     */
    const enum Direction {
        /**
         * Left to right
         */
        LeftToRight = 0,
        /**
         * Right to left
         */
        RightToLeft = 1,
    }

    /**
     * The enum used for increase or decrease indentation of a block
     * Used by setIndentation API
     */
    const enum Indentation {
        /**
         * Increase indentation
         */
        Increase = 0,
        /**
         * Decrease indentation
         */
        Decrease = 1,
    }

    /**
     * Paste option
     */
    const enum PasteOption {
        /**
         * Paste html with content type "text/html"
         */
        PasteHtml = 0,
        /**
         * Paste plain text with content type "text/plain"
         */
        PasteText = 1,
        /**
         * Paste image from clipboard with content type "image/*"
         */
        PasteImage = 2,
    }

    /**
     * TableOperation used by editTable API
     */
    const enum TableOperation {
        /**
         * Insert a row above current row
         */
        InsertAbove = 0,
        /**
         * Insert a row below current row
         */
        InsertBelow = 1,
        /**
         * Insert a column on the left of current column
         */
        InsertLeft = 2,
        /**
         * Insert a column on the right of current column
         */
        InsertRight = 3,
        /**
         * Delete the whole table
         */
        DeleteTable = 4,
        /**
         * Delete current column
         */
        DeleteColumn = 5,
        /**
         * Delete current row
         */
        DeleteRow = 6,
        /**
         * Merge current row with the row above
         */
        MergeAbove = 7,
        /**
         * Merge current row with the row below
         */
        MergeBelow = 8,
        /**
         * Merge current column with the column on the left
         */
        MergeLeft = 9,
        /**
         * Merge current column with the column on the right
         */
        MergeRight = 10,
        /**
         * Split current table cell horizontally
         */
        SplitHorizontally = 11,
        /**
         * Split current table cell vertically
         */
        SplitVertically = 12,
    }

    /**
     * An object contains all related data for pasting
     */
    interface ClipboardData {
        /**
         * An editor content snapshot before pasting happens. This is used for changing paste format
         */
        snapshotBeforePaste: string;
        /**
         * The format state at cursor before pasting. This is used for changing paste format
         */
        originalFormat: DefaultFormat;
        /**
         * Types of content included by the original onpaste event
         */
        types: string[];
        /**
         * If the copied data contains image format, this will be the image blob. Otherwise it is null.
         */
        image: File;
        /**
         * If the copied data contains plain text format, this will be the plain text string. Otherwise it is null.
         */
        text: string;
        /**
         * If the copied data contains HTML format, this will be the html string. Otherwise it is null.
         */
        html: string;
    }

    /**
     * Default format settings
     */
    interface DefaultFormat {
        /**
         * Font family
         */
        fontFamily?: string;
        /**
         * Font size
         */
        fontSize?: string;
        /**
         * Text color
         */
        textColor?: string;
        /**
         * Background Color
         */
        backgroundColor?: string;
        /**
         * Whether is bold
         */
        bold?: boolean;
        /**
         * Whether is italic
         */
        italic?: boolean;
        /**
         * Whether has underline
         */
        underline?: boolean;
    }

    /**
     * The format state
     */
    interface FormatState {
        /**
         * Font name
         */
        fontName?: string;
        /**
         * Font size
         */
        fontSize?: string;
        /**
         * Whether the text is bolded
         */
        isBold?: boolean;
        /**
         * Whether the text is italic
         */
        isItalic?: boolean;
        /**
         * Whether the text has underline
         */
        isUnderline?: boolean;
        /**
         * Background color
         */
        backgroundColor?: string;
        /**
         * Text color
         */
        textColor?: string;
        /**
         * Whether the text is in bullet mode
         */
        isBullet?: boolean;
        /**
         * Whether the text is in numbering mode
         */
        isNumbering?: boolean;
        /**
         * Whether the text has strike through line
         */
        isStrikeThrough?: boolean;
        /**
         * Whether the text is in block quote
         */
        isBlockQuote?: boolean;
        /**
         * Whether the text is in subscript mode
         */
        isSubscript?: boolean;
        /**
         * Whether the text is in superscript mode
         */
        isSuperscript?: boolean;
        /**
         * Whether unlink command can be called to the text
         */
        canUnlink?: boolean;
        /**
         * Whether add image alt text command can be called to the text
         */
        canAddImageAltText?: boolean;
        /**
         * Whether the content can be undone
         */
        canUndo?: boolean;
        /**
         * Whether the content ca nbe redone
         */
        canRedo?: boolean;
        /**
         * Header level (0-6, 0 means no header)
         */
        headerLevel?: number;
    }

    /**
     * LinkData represents a link match result
     */
    interface LinkData {
        /**
         * Schema of a hyperlink
         */
        scheme: string;
        /**
         * Original url of a hyperlink
         */
        originalUrl: string;
        /**
         * Normalized url of a hyperlink
         */
        normalizedUrl: string;
    }

    /**
     * This represents a rect inside editor
     */
    interface Rect {
        /**
         * Top
         */
        top: number;
        /**
         * Bottom
         */
        bottom: number;
        /**
         * Left
         */
        left: number;
        /**
         * Right
         */
        right: number;
    }

    /**
     * Table format
     */
    interface TableFormat {
        /**
         * Background color for even rows
         */
        bgColorEven: string;
        /**
         * Background color for odd rows
         */
        bgColorOdd: string;
        /**
         * Top border color for each row
         */
        topBorderColor: string;
        /**
         * Bottom border color for each row
         */
        bottomBorderColor: string;
        /**
         * Vertical border color for each row
         */
        verticalBorderColor: string;
    }

    /**
     * The position. Mostly used for content insertion and traversing
     * On insertion, we will need to specify where we want the content to be placed (begin, end, selection or outside)
     * On content traversing, we will need to specify the start position of traversing
     */
    const enum ContentPosition {
        /**
         * Begin of the container
         */
        Begin = 0,
        /**
         * End of the container
         */
        End = 1,
        /**
         * Selection start
         */
        SelectionStart = 2,
        /**
         * Outside of editor
         */
        Outside = 3,
    }

    /**
     * Options for insertContent API
     */
    interface InsertOption {
        /**
         * Target position
         */
        position: ContentPosition;
        /**
         * Whether need to update cursor
         */
        updateCursor: boolean;
        /**
         * Whether need to replace current selection
         */
        replaceSelection: boolean;
        /**
         * Whether need to insert the content into a new line
         */
        insertOnNewLine: boolean;
    }

    /**
     * Represents a custom PluginEvent for content change
     */
    interface ContentChangedEvent extends PluginEvent {
        /**
         * Source of the change
         */
        source: ChangeSource | string;
        /**
         * Optional related data
         */
        data?: any;
    }

    /**
     * Possible change sources. Here are the predefined sources.
     * It can also be other string if the change source can't fall into these sources.
     */
    const enum ChangeSource {
        /**
         * Content changed by auto bullet
         */
        AutoBullet = "AutoBullet",
        /**
         * Content changed by auto link
         */
        AutoLink = "AutoLink",
        /**
         * Content changed by create link
         */
        CreateLink = "CreateLink",
        /**
         * Content changed by format
         */
        Format = "Format",
        /**
         * Content changed by image resize
         */
        ImageResize = "ImageResize",
        /**
         * Content changed by paste
         */
        Paste = "Paste",
        /**
         * Content changed by setContent API
         */
        SetContent = "SetContent",
        /**
         * Content changed by cut operation
         */
        Cut = "Cut",
        /**
         * Content changed by drag & drop operation
         */
        Drop = "Drop",
    }

    /**
     * Represents a custom PluginEvent for extracting content
     */
    interface ExtractContentEvent extends PluginEvent {
        /**
         * Current content string
         * Plugin can change this string to clean up the markups it added before
         */
        content: string;
    }

    /**
     * This represents a PluginEvent for a DOM event
     */
    interface PluginDomEvent extends PluginEvent {
        /**
         * original DOM event
         */
        rawEvent: Event;
    }

    /**
     * Editor plugin event interface
     */
    interface PluginEvent {
        /**
         * Type of this event
         */
        eventType: PluginEventType;
        /**
         * An optional event cache.
         * This will be consumed by event cache API to store some expensive calculation result.
         * So that for the same event across plugins, the result doesn't need to be calculated again
         */
        eventDataCache?: {
            [key: string]: any;
        };
    }

    /**
     * Editor plugin event type
     */
    const enum PluginEventType {
        /**
         * HTML KeyDown event
         */
        KeyDown = 0,
        /**
         * HTML KeyPress event
         */
        KeyPress = 1,
        /**
         * HTML KeyUp event
         */
        KeyUp = 2,
        /**
         * HTML CompositionEnd event
         */
        CompositionEnd = 3,
        /**
         * HTML MouseDown event
         */
        MouseDown = 4,
        /**
         * HTML MouseUp event
         */
        MouseUp = 5,
        /**
         * Content changed event
         */
        ContentChanged = 6,
        /**
         * Extract Content event
         * This event is triggered when getContent() is called with triggerExtractContentEvent = true
         * Plugin can handle this event to remove the UI only markups to return clean HTML
         */
        ExtractContent = 7,
        /**
         * Before Paste event, provide a chance to change paste content
         */
        BeforePaste = 8,
        /**
         * Idle event, fired when user doesn't have any input for a time period (specified in EditorOptions)
         */
        Idle = 9,
    }

    /**
     * Provides a chance for plugin to change the content before it is pasted into editor.
     */
    interface BeforePasteEvent extends PluginEvent {
        /**
         * An object contains all related data for pasting
         */
        clipboardData: ClipboardData;
        /**
         * HTML Document Fragment which will be inserted into content if pasteOption is set to PasteHtml
         */
        fragment: DocumentFragment;
        /**
         * Paste option: html, text or image
         */
        pasteOption: PasteOption;
    }

    /**
     * The is essentially an enum representing result from browser compareDocumentPosition API
     * https: */
    const enum DocumentPosition {
        /**
         * Same node
         */
        Same = 0,
        /**
         * Node is disconnected from document
         */
        Disconnected = 1,
        /**
         * Node is preceding the comparing node
         */
        Preceding = 2,
        /**
         * Node is following the comparing node
         */
        Following = 4,
        /**
         * Node contains the comparing node
         */
        Contains = 8,
        /**
         * Node is contained by the comparing node
         */
        ContainedBy = 16,
    }

    /**
     * The is essentially an enum represents the type of the node
     * https: * Values not listed here are deprecated.
     */
    const enum NodeType {
        /**
         * An Element node such as <p> or <div>.
         */
        Element = 1,
        /**
         * The actual Text of Element or Attr.
         */
        Text = 3,
        /**
         * A ProcessingInstruction of an XML document such as <?xml-stylesheet ... ?> declaration.
         */
        ProcessingInstruction = 7,
        /**
         * A Comment node.
         */
        Comment = 8,
        /**
         * A Document node.
         */
        Document = 9,
        /**
         * A DocumentType node e.g. <!DOCTYPE html> for HTML5 documents.
         */
        DocumentType = 10,
        /**
         * A DocumentFragment node.
         */
        DocumentFragment = 11,
    }

    /**
     * Represent a position in DOM tree by the node and its offset index
     */
    class Position {
        readonly node: Node;
        readonly element: HTMLElement;
        readonly offset: number;
        readonly isAtEnd: boolean;
        /**
         * Clone and validate a position from existing position.
         * If the given position has invalid offset, this function will return a corrected value.
         * @param position The original position to clone from
         */
        constructor(position: Position);
        /**
         * Create a Position from node and an offset number
         * @param node The node of this position
         * @param offset Offset of this position
         */
        constructor(node: Node, offset: number);
        /**
         * Create a Position from node and a type of position
         * @param node The node of this position
         * @param positionType Type of the postion, can be Begin, End, Before, After
         */
        constructor(node: Node, positionType: PositionType);
        /**
         * Normalize this position the leaf node, return the normalize result.
         * If current position is already using leaf node, return this position object itself
         */
        normalize(): Position;
        /**
         * Check if this position is equal to the given position
         * @param p The position to check
         */
        equalTo(p: Position): boolean;
        /**
         * Checks if position 1 is after position 2
         */
        isAfter(p: Position): boolean;
        /**
         * Get bounding rect of this position
         */
        getRect(): Rect;
        /**
         * Move this position with offset, returns a new position with a valid offset in the same node
         * @param offset Offset to move with
         */
        move(offset: number): Position;
    }

    /**
     * Represent a selection range in DOM tree
     */
    class SelectionRange {
        /**
         * Check if this selection range is collapsed
         */
        readonly collapsed: boolean;
        /**
         * Get the start position
         */
        readonly start: Position;
        /**
         * Get the end position
         */
        readonly end: Position;
        private rawRange;
        /**
         * Create a SelectionRange object using a browser range object
         * @param rawRange The browser range object
         */
        constructor(rawRange: Range);
        /**
         * Create a SelectionRange object using start and end position
         * @param start The start position
         * @param end The end position
         */
        constructor(start: Position, end?: Position);
        /**
         * Retrieve the browser range object
         */
        getRange(): Range;
        /**
         * Normal this selction range by normalizing its start and end position
         */
        normalize(): SelectionRange;
        /**
         * Replace this range with a node
         * @param node The node to be inserted
         * @returns True if we complete the replacement, false otherwise
         */
        replaceWithNode(node: Node): boolean;
    }

    /**
     * Represent the type of a position
     */
    const enum PositionType {
        /**
         * Before a node
         */
        Before = "b",
        /**
         * At the begninning of a node
         */
        Begin = 0,
        /**
         * At the endo of a node
         */
        End = "e",
        /**
         * After a node
         */
        After = "a",
    }

    /**
     * This walks forwards (from left to right) DOM tree to get next meaningful node
     * A null is returned when it reaches the very end - beyond the scope as defined by rootNode
     */
    function getNextLeafSibling(rootNode: Node, startNode: Node): Node;

    /**
     * This walks backwards (from right to left) DOM tree to get previous meaningful node
     * A null is returned when it reaches the very first - beyond the scope as defined by rootNode
     */
    function getPreviousLeafSibling(rootNode: Node, startNode: Node): Node;

    /**
     * Get the first meaningful leaf node
     * This can return null for empty container or
     * container that does not contain any meaningful node
     * @param rootNode The root node to get leaf node from
     */
    function getFirstLeafNode(rootNode: Node): Node;

    /**
     * Get the last meaningful leaf node
     * This can return null for empty container or
     * container that does not contain any meaningful node
     * @param rootNode The root node to get leaf node from
     */
    function getLastLeafNode(rootNode: Node): Node;

    /**
     * Get the first or last meaningful leaf node
     * This can return null for empty container or
     * container that does not contain any meaningful node
     * @param rootNode The root node to get leaf node from
     * @param isFirst True to get first leaf node, false to get last leaf node
     */
    function getLeafNode(rootNode: Node, isFirst: boolean): Node;

    /**
     * This refers to an inline element (as opposed to block) in editor
     * Inline and block makes the "type" system in editor.
     * An inline element is a maximum resolvable "entity" within the boundary of a block
     * At minimum and also most commonly, it represents a text node.
     * It can represent broader "content" depending on the resolvers that are available, i.e.
     * it can be anchor link, image, emoji, ...
     * Two rules:
     * 1) every inline element must have a container node (text or span, a etc.)
     * 2) inline element cannot be nested
     */
    interface InlineElement {
        /**
         * Get the text content of this inline element
         */
        getTextContent: () => string;
        /**
         * Get the container node of this inline element
         */
        getContainerNode: () => Node;
        /**
         * Get the start position of this inline element
         */
        getStartPosition: () => Position;
        /**
         * Get the end position of this inline element
         */
        getEndPosition: () => Position;
        /**
         * Get a value to indicate whether this element contains text only
         */
        isText: () => boolean;
        /**
         * Checks if the given inline element is after this inline element
         */
        isAfter: (inlineElement: InlineElement) => boolean;
        /**
         * Checks if the given editor position is contained in this inline element
         */
        contains: (position: Position) => boolean;
        /**
         * Apply inline style to an inline element
         */
        applyStyle: (styler: (element: HTMLElement) => void) => void;
    }

    /**
     * This presents an inline element that can be reprented by a single html node.
     * This serves as base for most inline element as it contains most implentation
     * of all operations that can happen on an inline element. Other sub inline elements mostly
     * just identify themself for a certain type
     */
    class NodeInlineElement implements InlineElement {
        private containerNode;
        constructor(containerNode: Node);
        /**
         * The text content for this inline element
         */
        getTextContent(): string;
        /**
         * Get the container node
         */
        getContainerNode(): Node;
        /**
         * Get the start point of the inline element
         */
        getStartPosition(): Position;
        /**
         * Get the end point of the inline element
         */
        getEndPosition(): Position;
        /**
         * Get a value to indicate whether this element contains text only
         */
        isText(): boolean;
        /**
         * Checks if an inline element is after the current inline element
         */
        isAfter(inlineElement: InlineElement): boolean;
        /**
         * Checks if an editor point is contained in the inline element
         */
        contains(position: Position): boolean;
        /**
         * Apply inline style to an inline element
         */
        applyStyle(styler: (element: HTMLElement) => void): void;
    }

    /**
     * This is a special version of inline element that identifies a section of an inline element
     * We often have the need to cut an inline element in half and perform some operation only on half of an inline element
     * i.e. users select only some text of a text node and apply format, in that case, format has to happen on partial of an inline element
     * PartialInlineElement is implemented in a way that decorate another full inline element with its own override on methods like isAfter
     * It also offers some special methods that others don't have, i.e. nextInlineElement etc.
     */
    class PartialInlineElement implements InlineElement {
        private decoratedInline;
        private start;
        private end;
        constructor(decoratedInline: InlineElement, start: Position, end: Position);
        /**
         * Get the full inline element that this partial inline decorates
         */
        getDecoratedInline(): NodeInlineElement;
        /**
         * Gets the container node
         */
        getContainerNode(): Node;
        /**
         * Gets the text content
         */
        getTextContent(): string;
        /**
         * Gets the start position
         */
        getStartPosition(): Position;
        /**
         * Gets the end position
         */
        getEndPosition(): Position;
        /**
         * Checks if it contains a position
         */
        contains(p: Position): boolean;
        /**
         * Get a value to indicate whether this element contains text only
         */
        isText(): boolean;
        /**
         * Check if this inline element is after the other inline element
         */
        isAfter(inlineElement: InlineElement): boolean;
        /**
         * Apply style to the content between start and end position
         * @param styler A callback function to do styling change to an html element
         */
        applyStyle(styler: (element: HTMLElement) => void): void;
    }

    /**
     * Get the inline element at a node
     * @param node The node to get InlineElement froms
     */
    function getInlineElementAtNode(node: Node): InlineElement;

    /**
     * This refers to a "content block" in editor that serves as a content parsing boundary
     * It is most those html block like tags, i.e. <p>, <div>, <li>, <td> etc.
     * but can also be just a text node, followed by a <br>, i.e.
     * for html fragment <div>abc<br>123</div>, abc<br> is a block, 123 is another block
     */
    interface BlockElement {
        /**
         * Get text content of this block element
         */
        getTextContent(): string;
        /**
         * Get start node of this block element
         */
        getStartNode(): Node;
        /**
         * Get end node of this block element
         */
        getEndNode(): Node;
        /**
         * Get content nodes of this block element as node array
         */
        getContentNodes(): Node[];
        /**
         * Get the first inline element of this block element
         */
        getFirstInlineElement(): InlineElement;
        /**
         * Get the last inline element of this block element
         */
        getLastInlineElement(): InlineElement;
        /**
         * Check whether this block element equals to the given block element
         */
        equals(blockElement: BlockElement): boolean;
        /**
         * Checks if this block element is after another block element
         */
        isAfter(blockElement: BlockElement): boolean;
        /**
         * Check if the given inline element falls within this block element
         */
        contains(inlineElement: InlineElement): boolean;
        /**
         * Check if the given node is within this block element
         */
        contains(node: Node): boolean;
    }

    /**
     * This presents a content block that can be reprented by a single html block type element.
     * In most cases, it corresponds to an HTML block level element, i.e. P, DIV, LI, TD etc.
     */
    class NodeBlockElement extends StartEndBlockElement {
        /**
         * Create a new instance of NodeBlockElement class
         * @param containerNode The container DOM Node of this NodeBlockElement
         */
        constructor(containerNode: Node);
        /**
         * Gets first inline
         */
        getFirstInlineElement(): InlineElement;
        /**
         * Gets last inline
         */
        getLastInlineElement(): InlineElement;
        contains(arg: InlineElement | Node): boolean;
    }

    /**
     * This reprents a block that is identified by a start and end node
     * This is for cases like <ced>Hello<BR>World</ced>
     * in that case, Hello<BR> is a block, World is another block
     * Such block cannot be represented by a NodeBlockElement since they don't chained up
     * to a single parent node, instead they have a start and end
     * This start and end must be in same sibling level and have same parent in DOM tree
     */
    class StartEndBlockElement implements BlockElement {
        protected startNode: Node;
        protected endNode: Node;
        protected firstInline: InlineElement;
        protected lastInline: InlineElement;
        /**
         * Create a new instance of StartEndBlockElement class
         * @param rootNode rootNode of current scope
         * @param startNode startNode of this block element
         * @param endNode end nod of this block element
         */
        constructor(startNode: Node, endNode: Node);
        /**
         * Gets the text content
         */
        getTextContent(): string;
        /**
         * Get all nodes represented in a Node array
         * This only works for balanced node -- start and end is at same level
         */
        getContentNodes(): Node[];
        /**
         * Gets the start node
         */
        getStartNode(): Node;
        /**
         * Gets the end node
         */
        getEndNode(): Node;
        /**
         * Gets first inline
         */
        getFirstInlineElement(): InlineElement;
        /**
         * Gets last inline
         */
        getLastInlineElement(): InlineElement;
        /**
         * Checks equals of two blocks
         */
        equals(blockElement: BlockElement): boolean;
        /**
         * Checks if this block element is after another block element
         */
        isAfter(blockElement: BlockElement): boolean;
        /**
         * Checks if an inline falls inside me
         */
        contains(inlineElement: InlineElement): boolean;
        /**
         * Checks if an Html node is contained within the block
         */
        contains(node: Node): boolean;
    }

    /**
     * This produces a block element from a a node
     * It needs to account for various HTML structure. Examples:
     * 1) <ced><div>abc</div></ced>
     *   This is most common the case, user passes in a node pointing to abc, and get back a block representing <div>abc</div>
     * 2) <ced><p><br></p></ced>
     *   Common content for empty block, user passes node pointing to <br>, and get back a block representing <p><br></p>
     * 3) <ced>abc</ced>
     *   Not common, but does happen. It is still a block in user's view. User passes in abc, and get back a start-end block representing abc
     *   NOTE: abc could be just one node. However, since it is not a html block, it is more appropriate to use start-end block although they point to same node
     * 4) <ced><div>abc<br>123</div></ced>
     *   A bit tricky, but can happen when user use Ctrl+Enter which simply inserts a <BR> to create a link break. There're two blocks:
     *   block1: 1) abc<br> block2: 123
     * 5) <ced><div>abc<div>123</div></div></ced>
     *   Nesting div and there is text node in same level as a DIV. Two blocks: 1) abc 2) <div>123</div>
     * 6) <ced><div>abc<span>123<br>456</span></div></ced>
     *   This is really tricky. Essentially there is a <BR> in middle of a span breaking the span into two blocks;
     *   block1: abc<span>123<br> block2: 456
     * In summary, given any arbitary node (leaf), to identify the head and tail of the block, following rules need to be followed:
     * 1) to identify the head, it needs to crawl DOM tre left/up till a block node or BR is encountered
     * 2) same for identifying tail
     * 3) should also apply a block ceiling, meaning as it crawls up, it should stop at a block node
     */
    function getBlockElementAtNode(rootNode: Node, node: Node): BlockElement;

    /**
     * The provides traversing of content inside editor.
     * There are two ways to traverse, block by block, or inline element by inline element
     * Block and inline traversing is independent from each other, meanning if you traverse block by block, it does not change
     * the current inline element position
     */
    class ContentTraverser {
        private rootNode;
        private currentInline;
        private currentBlock;
        private scoper;
        /**
         * Create a content traverser for the whole body of given root node
         * @param rootNode The root node to traverse in
         */
        constructor(rootNode: Node);
        /**
         * Create a content traverser for the given selection
         * @param rootNode The root node to traverse in
         * @param range The selection range to scope the traversing
         */
        constructor(rootNode: Node, range: SelectionRange);
        /**
         * Create a content traverser for a block element which contains the given position
         * @param rootNode The root node to traverse in
         * @param positionInBlock A position inside a block, traversing will be scoped within this block
         * @param startFrom Start position of traversing. The value can be Begin, End, SelectionStart
         */
        constructor(rootNode: Node, positionInBlock: Position, startFrom: ContentPosition);
        /**
         * Get current block
         */
        readonly currentBlockElement: BlockElement;
        /**
         * Get next block element
         */
        getNextBlockElement(): BlockElement;
        /**
         * Get previous block element
         */
        getPreviousBlockElement(): BlockElement;
        /**
         * Current inline element getter
         */
        readonly currentInlineElement: InlineElement;
        /**
         * Get next inline element
         */
        getNextInlineElement(): InlineElement;
        /**
         * Get previous inline element
         */
        getPreviousInlineElement(): InlineElement;
        private getNextPreviousBlockElement(current, isNext);
    }

    /**
     * A helper class to traverse text inline elements before a position
     */
    class TextBeforePositionTraverser {
        private traverser;
        private text;
        private word;
        private inlineElement;
        private traversingCompleted;
        private inlineElements;
        private nearestNonTextInlineElement;
        /**
         * Create a new TextBeforePositionTraverser instance
         * @param traverser The content traverser to help find data before position
         */
        constructor(traverser: ContentTraverser);
        /**
         * Get the word before cursor. The word is determined by scanning backwards till the first white space, the portion
         * between cursor and the white space is the word before cursor
         * @returns The word before cursor
         */
        getWordBeforeCursor(): string;
        /**
         * Get the inline element before cursor
         * @returns The inlineElement before cursor
         */
        getInlineElementBeforeCursor(): InlineElement;
        /**
         * Get X number of chars before cursor
         * The actual returned chars may be less than what is requested.
         * @param length The length of string user want to get, the string always ends at the cursor,
         * so this length determins the start position of the string
         * @returns The actual string we get as a sub string, or the whole string before cursor when
         * there is not enough chars in the string
         */
        getSubStringBeforeCursor(length: number): string;
        /**
         * Try to get a range matches the given text before the cursor
         * @param text The text to match against
         * @param exactMatch Whether it is an exact match
         * @returns The range for the matched text, null if unable to find a match
         */
        getRangeWithForTextBeforeCursor(text: string, exactMatch: boolean): SelectionRange;
        /**
         * Get text section before cursor till stop condition is met.
         * This offers consumers to retrieve text section by section
         * The section essentially is just an inline element which has Container element
         * so that the consumer can remember it for anchoring popup or verification purpose
         * when cursor moves out of context etc.
         * @param callback The callback function of each inline element.
         * Return true from this callback to stop the loop
         */
        forEachTextInlineElement(callback: (textInlineElement: InlineElement) => boolean): void;
        /**
         * Get first non textual inline element before cursor
         * @returns First non textutal inline element before cursor or null if no such element exists
         */
        getNearestNonTextInlineElement(): InlineElement;
        /**
         * Continue traversing backward till stop condition is met or begin of block is reached
         */
        private travel(callback);
    }

    const Browser: BrowserInfo;

    /**
     * Information of current OS and web browser
     */
    interface BrowserInfo {
        /**
         * Wether current OS is Mac
         */
        isMac?: boolean;
        /**
         * Whether current OS is Windows
         */
        isWin?: boolean;
        /**
         * Whether current browser is Internet Explorer
         */
        isIE?: boolean;
        /**
         * Whether current browser is Safari
         */
        isSafari?: boolean;
        /**
         * Whether current browser is Chrome
         */
        isChrome?: boolean;
        /**
         * Whether current browser is Firfox
         */
        isFirefox?: boolean;
        /**
         * Whether current browser is Edge
         */
        isEdge?: boolean;
    }

    /**
     * Apply format to an HTML element
     * @param element The HTML element to apply format to
     * @param format The format to apply
     */
    function applyFormat(element: HTMLElement, format: DefaultFormat): void;

    /**
     * Change tag of ab HTML Element to a new one, and replace it from DOM tree
     * @param element The element to change tag
     * @param newTag New tag to change to
     * @returns The new Node with new tag
     */
    function changeElementTag(element: HTMLElement, newTag: string): HTMLElement;

    /**
     * Test if a node contains another node
     * @param container The container node
     * @param contained The node to check if it is inside container
     * @param treatSameNodeAsContain When container and contained are the same node,
     * return true if this param is set to true, otherwise return false. Default value is false
     * @returns True if contained is insied container, or they are the same node when treatSameNodeAsContain is true.
     * Otherwise false.
     */
    function contains(container: Node, contained: Node, treatSameNodeAsContain?: boolean): boolean;

    /**
     * Test if a node contains a given range
     * @param container The container node
     * @param contained The range to check if it is inside container
     * @returns True if contained is insied container, otherwise false
     */
    function contains(container: Node, contained: Range): boolean;

    /**
     * Test if a node contains a given range
     * @param container The container node
     * @param contained The selection range to check if it is inside container
     * @returns True if contained is insied container, otherwise false
     */
    function contains(container: Node, contained: SelectionRange): boolean;

    /**
     * Sanitize HTML string
     * This function will do the following work:
     * 1. Convert global CSS into inline CSS
     * 2. Remove dangerous HTML tags and attributes
     * 3. Remove useless CSS properties
     * @param html The input HTML
     * @param additionalStyleNodes additional style nodes for inline css converting
     * @param convertInlineCssOnly Whether only convert inline css and skip html content sanitizing
     * @param propertyCallbacks A callback function map to handle HTML properties
     * @param preserveFragmentOnly If set to true, only preserve the html content between <!--StartFragment--> and <!--Endfragment-->
     */
    function sanitizeHtml(html: string, additionalStyleNodes?: HTMLStyleElement[], convertInlineCssOnly?: boolean, propertyCallbacks?: SanitizeHtmlPropertyCallback, currentStyle?: StyleMap, preserveFragmentOnly?: boolean): string;

    /**
     * Callback function set for sanitizeHtml().
     * sanitizeHtml() will check if there is a callback function for a given property name,
     * it will call this function to decide what value to set for this property.
     * Return null will cause this property be deleted, otherwise return the value of the property
     */
    type SanitizeHtmlPropertyCallback = {
        [name: string]: (value: string) => string;
    };

    /**
     * A map from CSS style name to its value
     */
    type StyleMap = {
        [name: string]: string;
    };

    /**
     * Creates an HTML node array from html
     * @param html the html string to create HTML elements from
     * @param ownerDocument Owner document of the result HTML elements
     * @param sanitize Whether do sanitization before create elements to avoid XSS. Default value is false
     * @returns An HTML node array to represent the given html string
     */
    function fromHtml(html: string, ownerDocument: HTMLDocument, sanitize?: boolean): Node[];

    /**
     * Get computed styles of a node
     * @param node The node to get computed styles from
     * @param styleNames Names of style to get, can be a single name or an array.
     * Default value is font-family, font-size, color, background-color
     * @returns An array of the computed styles
     */
    function getComputedStyles(node: Node, styleNames?: string | string[]): string[];

    /**
     * Get element from node or its parent
     * @param node The node to get element from
     * @returns node itself if the node is an element, or its parent node
     */
    function getElementOrParentElement(node: Node): HTMLElement;

    /**
     * Get the html tag of a node, or empty if it is not an element
     * @param node The node to get tag of
     * @returns Tag name in upper case if the given node is an Element, or empty string otherwise
     */
    function getTagOfNode(node: Node): string;

    /**
     * Check if a given node has intersection with the given node range
     * @param node The node to check
     * @param start Start node of the range
     * @param end End node of the range
     * @param nodeContainedByRangeOnly When set to true, will return true only when the node is between
     * start and end nodes or contained by start or end node. When set to false, also return true
     * if the node contains both start and end node
     * @return True if the node has intersection with the range. Otherwise false
     */
    function intersectWithNodeRange(node: Node, start: Node, end: Node, nodeContainedByRangeOnly?: boolean): boolean;

    /**
     * Checks if the node is a block like element. Block like element are usually those P, DIV, LI, TD etc.
     * @param node The node to check
     * @returns True if the node is a block element, otherwise false
     */
    function isBlockElement(node: Node): boolean;

    /**
     * Check if position is or encompasses any of targets
     * @param position The doucment position to check
     * @param targets The target position or position array
     */
    function isDocumentPosition(position: DocumentPosition, targets: DocumentPosition | DocumentPosition[]): boolean;

    /**
     * Check if a given node has no visible content
     * @param node The node to check
     * @param trimContent Whether trim the text content so that spaces will be treated as empty.
     * Default value is false
     * @returns True if there isn't any visible element inside node, otherwise false
     */
    function isNodeEmpty(node: Node, trimContent?: boolean): boolean;

    /**
     * check if it is html void element. void element cannot have childen
     */
    function isVoidHtmlElement(element: HTMLElement): boolean;

    /**
     * Try to match a given string with link match rules, return matched link
     * @param url Input url to match
     * @param option Link match option, exact or partial. If it is exact match, we need
     * to check the length of matched link and url
     * @param rules Optional link match rules, if not passed, only the default link match
     * rules will be applied
     * @returns The matched link data, or null if no match found.
     * The link data includes an original url and a normalized url
     */
    function matchLink(url: string): LinkData;

    /**
     * Split parent node of the given node before/after the given node.
     * When a parent node contains [A,B,C] and pass B as the given node,
     * If split before, the new nodes will be [A][B,C] and returns [A];
     * otherwise, it will be [A,B][C] and returns [C].
     * @param node The node to split before/after
     * @param splitBefore Whether split before or after
     * @returns The new parent node
     */
    function splitParentNode(node: Node, splitBefore: boolean): Node;

    /**
     * Removes the node and keep all children in place, return the parentNode where the children are attached
     * @param node the node to remove
     */
    function unwrap(node: Node): Node;

    /**
     * Wrap all the node with html and return the wrapped node, and put the wrapper node under the parent of the first node
     * @param nodes The node or node array to wrap
     * @param wrapper The wrapper node or HTML string, default value is <div></div>
     * @param sanitize Whether do sanitization of wrapper string before create node to avoid XSS,
     * default value is false
     * @returns The wrapper element
     */
    function wrap(nodes: Node | Node[], wrapper?: string | HTMLElement, sanitize?: boolean): HTMLElement;

    /**
     * RoosterJs core editor class
     */
    class Editor {
        private omitContentEditable;
        private disableRestoreSelectionOnFocus;
        private inIME;
        private core;
        private eventDisposers;
        private defaultRange;
        /**
         * Creates an instance of Editor
         * @param contentDiv The DIV HTML element which will be the container element of editor
         * @param options An optional options object to customize the editor
         */
        constructor(contentDiv: HTMLDivElement, options?: EditorOptions);
        /**
         * Dispose this editor, dispose all plugins and custom data
         */
        dispose(): void;
        /**
         * Get whether this editor is disposed
         * @returns True if editor is disposed, otherwise false
         */
        isDisposed(): boolean;
        /**
         * Insert node into editor
         * @param node The node to insert
         * @param option Insert options. Default value is:
         *  position: ContentPosition.SelectionStart
         *  updateCursor: true
         *  replaceSelection: true
         *  insertOnNewLine: false
         * @returns true if node is inserted. Otherwise false
         */
        insertNode(node: Node, option?: InsertOption): boolean;
        /**
         * Delete a node from editor content
         * @param node The node to delete
         * @returns true if node is deleted. Otherwise false
         */
        deleteNode(node: Node): boolean;
        /**
         * Replace a node in editor content with another node
         * @param existingNode The existing node to be replaced
         * @param new node to replace to
         * @returns true if node is replaced. Otherwise false
         */
        replaceNode(existingNode: Node, toNode: Node): boolean;
        /**
         * Get BlockElement at given node
         * @param node The node to create InlineElement
         * @requires The BlockElement result
         */
        getBlockElementAtNode(node: Node): BlockElement;
        /**
         * Check if the node falls in the editor content
         * @param node The node to check
         * @returns True if the given node is in editor content, otherwise false
         */
        contains(node: Node): boolean;
        /**
         * Check if the range falls in the editor content
         * @param range The range to check
         * @returns True if the given range is in editor content, otherwise false
         */
        contains(range: Range): boolean;
        /**
         * Check if the selection range falls in the editor content
         * @param range The range to check
         * @returns True if the given range is in editor content, otherwise false
         */
        contains(range: SelectionRange): boolean;
        /**
         * Check whether the editor contains any visible content
         * @param trim Whether trime the content string before check. Default is false
         * @returns True if there's no visible content, otherwise false
         */
        isEmpty(trim?: boolean): boolean;
        /**
         * Get current editor content as HTML string
         * @param triggerExtractContentEvent Whether trigger ExtractContent event to all plugins
         * before return. Use this parameter to remove any temporary content added by plugins.
         * @returns HTML string representing current editor content
         */
        getContent(triggerExtractContentEvent?: boolean): string;
        /**
         * Get plain text content inside editor
         * @returns The text content inside editor
         */
        getTextContent(): string;
        /**
         * Set HTML content to this editor. All existing content will be replaced. A ContentChanged event will be triggered
         * @param content HTML content to set in
         * @param callbackBeforeTriggerContentChangedEvent An optional callback function, will be called before ContentChangedEvent is triggered
         */
        setContent(content: string, callbackBeforeTriggerContentChangedEvent?: () => void): void;
        /**
         * Insert HTML content into editor
         * @param HTML content to insert
         * @param option Insert options. Default value is:
         *  position: ContentPosition.SelectionStart
         *  updateCursor: true
         *  replaceSelection: true
         *  insertOnNewLine: false
         * @param sanitize True to do sanitizeHtml before insert, otherwise false
         */
        insertContent(content: string, option?: InsertOption, sanitize?: boolean): void;
        /**
         * DOM query nodes in editor
         * @param selector Selector string to query
         * @param forEachCallback An optional callback to be invoked on each node in query result
         * @returns Node list of the query result
         */
        queryNodes<T extends Node = Node>(selector: string, forEachCallback?: (node: T) => void): T[];
        /**
         * Get a SelectionRange object represents current selection in editor.
         * When editor has a live selection, this will return the selection.
         * When editor doesn't have a live selection, but it has a cached selection, this will return the cached selection.
         * Otherwise, return a selection of beginning of editor
         */
        getSelectionRange(): SelectionRange;
        /**
         * Get a Rect object represents the bounding rect of current focus point in editor.
         * If the editor doesn't have a live focus point, returns null
         */
        getCursorRect(): Rect;
        /**
         * Check if focus is in editor now
         * @returns true if focus is in editor, otherwise false
         */
        hasFocus(): boolean;
        /**
         * Focus to this editor, the selection was restored to where it was before, no unexpected scroll.
         */
        focus(): void;
        /**
         * Select content by range
         * @param range The range to select
         * @returns True if content is selected, otherwise false
         */
        select(range: Range): boolean;
        /**
         * Select content by SelectionRange
         * @param range The SelectionRange object which represents the content range to select
         * @returns True if content is selected, otherwise false
         */
        select(range: SelectionRange): boolean;
        /**
         * Select content by Position and collapse to this position
         * @param position The position to select
         * @returns True if content is selected, otherwise false
         */
        select(position: Position): boolean;
        /**
         * Select content by a start and end position
         * @param start The start position to select
         * @param end The end position to select, if this is the same with start, the selection will be collapsed
         * @returns True if content is selected, otherwise false
         */
        select(start: Position, end: Position): boolean;
        /**
         * Select content by node
         * @param node The node to select
         * @returns True if content is selected, otherwise false
         */
        select(node: Node): boolean;
        /**
         * Select content by node and offset, and collapse to this position
         * @param node The node to select
         * @param offset The offset of node to select, can be a number or value of PositionType
         * @returns True if content is selected, otherwise false
         */
        select(node: Node, offset: number | PositionType): boolean;
        /**
         * Select content by start and end nodes and offsets
         * @param startNode The node to select start from
         * @param startOffset The offset to select start from
         * @param endNode The node to select end to
         * @param endOffset The offset to select end to
         * @returns True if content is selected, otherwise false
         */
        select(startNode: Node, startOffset: number | PositionType, endNode: Node, endOffset: number | PositionType): boolean;
        /**
         * Add a custom DOM event handler to handle events not handled by roosterjs.
         * Caller need to take the responsibility to dispose the handler properly
         * @param eventName DOM event name to handle
         * @param handler Handler callback
         * @returns A dispose function. Call the function to dispose this event handler
         */
        addDomEventHandler(eventName: string, handler: (event: UIEvent) => void): () => void;
        /**
         * Trigger an event to be dispatched to all plugins
         * @param pluginEvent The event object to trigger
         * @param broadcast indicates if the event needs to be dispatched to all plugins
         * True means to all, false means to allow exclusive handling from one plugin unless no one wants that
         */
        triggerEvent(pluginEvent: PluginEvent, broadcast?: boolean): void;
        /**
         * Trigger a ContentChangedEvent
         * @param source Source of this event, by default is 'SetContent'
         * @param data additional data for this event
         */
        triggerContentChangedEvent(source?: ChangeSource | string, data?: any): void;
        /**
         * Undo last edit operation
         */
        undo(): void;
        /**
         * Redo next edit operation
         */
        redo(): void;
        /**
         * Add undo snapshot, and execute a format callback function, then add another undo snapshot if
         * addsnapshotAfterFormat is set to true, finally trigger ContentChangedEvent with given change source.
         * If this function is called nested, undo snapshot will only be added in the outside one
         * @param callback The callback function to perform formatting
         * @param preserveSelection Set to true to try preserve the selection after format
         * @param addsnapshotAfterFormat Whether should add an undo snapshot after format callback is called
         * @param changeSource The change source to use when fire ContentChangedEvent. Default value is 'Format'
         * If pass null, the event will not be fired.
         * @param dataCallback A callback function to retrieve the data for ContentChangedEvent
         * @param skipAddingUndoAfterFormat Set to true to only add undo snapshot before format. Default value is false
         */
        formatWithUndo(callback: () => void | Node, preserveSelection?: boolean, changeSource?: ChangeSource | string, dataCallback?: () => any, skipAddingUndoAfterFormat?: boolean): void;
        /**
         * Whether there is an available undo snapshot
         */
        canUndo(): boolean;
        /**
         * Whether there is an available redo snapshot
         */
        canRedo(): boolean;
        /**
         * Get document which contains this editor
         * @returns The HTML document which contains this editor
         */
        getDocument(): Document;
        /**
         * Get custom data related to this editor
         * @param key Key of the custom data
         * @param getter Getter function. If custom data for the given key doesn't exist,
         * call this function to get one and store it.
         * @param disposer An optional disposer function to dispose this custom data when
         * dispose editor.
         */
        getCustomData<T>(key: string, getter: () => T, disposer?: (value: T) => void): T;
        /**
         * Check if editor is in IME input sequence
         * @returns True if editor is in IME input sequence, otherwise false
         */
        isInIME(): boolean;
        /**
         * Get default format of this editor
         * @returns Default format object of this editor
         */
        getDefaultFormat(): DefaultFormat;
        /**
         * Get a content traverser for the whole editor
         */
        getBodyTraverser(): ContentTraverser;
        /**
         * Get a content traverser for current selection
         */
        getSelectionTraverser(): ContentTraverser;
        /**
         * Get a content traverser for current block element start from specified position
         * @param startFrom Start position of the traverser
         */
        getBlockTraverser(startFrom?: ContentPosition): ContentTraverser;
        /**
         * Get a text traverser to help get text before current focused position
         */
        getTextBeforePositionTraverser(): TextBeforePositionTraverser;
        /**
         * Run a callback function asynchronously
         * @param callback The callback function to run
         */
        runAsync(callback: () => void): void;
        private createEventHandlers();
        /**
         * Check if user is typing right under the content div
         * When typing goes directly under content div, many things can go wrong
         * We fix it by wrapping it with a div and reposition cursor within the div
         */
        private onKeyPress;
        /**
         * Check if user will type right under the content div
         * When typing goes directly under content div, many things can go wrong
         * We fix it by wrapping it with a div and reposition cursor within the div
         */
        private fixContentStructure(node);
    }

    /**
     * The options to specify parameters customizing an editor, used by ctor of Editor class
     */
    interface EditorOptions {
        /**
         * List of plugins.
         * The order of plugins here determines in what order each event will be dispatched.
         * Plugins not appear in t his list will not be added to editor, including bulit-in plugins.
         * Default value is empty array.
         */
        plugins?: EditorPlugin[];
        /**
         * Default format of editor content. This will be applied to empty content.
         * If there is already content inside editor, format of existing content will not be changed.
         * Default value is the computed style of editor content DIV
         */
        defaultFormat?: DefaultFormat;
        /**
         * Undo service object. Use this parameter to customize the undo service.
         * Default value is a new instance of Undo object
         */
        undo?: UndoService;
        /**
         * Initial HTML content
         * Default value is whatever already inside the editor content DIV
         */
        initialContent?: string;
        /**
         * Time interval for Idle event, in seconds. If not passed or 0, Idle event will not be fired.
         */
        idleEventTimeSpanInSecond?: number;
        /**
         * Whether auto restore previous selection when focus to editor
         * Default value is false
         */
        disableRestoreSelectionOnFocus?: boolean;
        /**
         * Whether skip setting contenteditable attribute to content DIV
         * Default value is false
         */
        omitContentEditableAttributeChanges?: boolean;
    }

    /**
     * Interface of an editor plugin
     */
    interface EditorPlugin {
        /**
         * The first method that editor will call to a plugin when editor is initializing.
         * It will pass in the editor instance, plugin should take this chance to save the
         * editor reference so that it can call to any editor method or format API later.
         * @param editor The editor object
         */
        initialize: (editor: Editor) => void;
        /**
         * The last method that editor will call to a plugin before it is disposed.
         * Plugin can take this chance to clear the reference to editor. After this method is
         * called, plugin should not call to any editor method since it will result in error.
         */
        dispose: () => void;
        /**
         * Check if the plugin should handle the given event exclusively.
         * Handle an event exclusively means other plugin will not receive this event in
         * onPluginEvent method.
         * If two plugins will return true in willHandleEventExclusively() for the same event,
         * the final result depends on the order of the plugins are added into editor
         * @param event The event to check:
         */
        willHandleEventExclusively?: (event: PluginEvent) => boolean;
        /**
         * Core method for a plugin. Once an event happens in editor, editor will call this
         * method of each plugin to handle the event as long as the event is not handled
         * exclusively by another plugin.
         * @param event The event to handle:
         */
        onPluginEvent?: (event: PluginEvent) => void;
    }

    /**
     * Provides snapshot based undo service for Editor
     */
    class Undo implements UndoService {
        private preserveSnapshots;
        private maxBufferSize;
        private editor;
        private isRestoring;
        private hasNewContent;
        private undoSnapshots;
        private lastKeyPress;
        private onDropDisposer;
        private onCutDisposer;
        /**
         * Create an instance of Undo
         * @param preserveSnapshots True to preserve the snapshots after dispose, this allows
         * this object to be reused when editor is disposed and created again
         * @param maxBufferSize The max buffer size for snapshots. Default value is 10MB
         */
        constructor(preserveSnapshots?: boolean, maxBufferSize?: number);
        /**
         * Initialize this plugin. This should only be called from Editor
         * @param editor Editor instance
         */
        initialize(editor: Editor): void;
        /**
         * Dispose this plugin
         */
        dispose(): void;
        /**
         * Handle events triggered from editor
         * @param event PluginEvent object
         */
        onPluginEvent(event: PluginEvent): void;
        /**
         * Clear all existing undo snapshots
         */
        clear(): void;
        /**
         * Restore an undo snapshot to editor
         */
        undo(): void;
        /**
         * Restore a redo snapshot to editor
         */
        redo(): void;
        /**
         * Whether there is a snapshot for undo
         */
        canUndo(): boolean;
        /**
         * Whether there is a snapshot for redo
         */
        canRedo(): boolean;
        /**
         * Add an undo snapshot
         */
        addUndoSnapshot(): void;
        private restoreSnapshot(delta);
        private onKeyDown(pluginEvent);
        private onKeyPress(pluginEvent);
        private clearRedoForInput();
        private getSnapshotsManager();
        private onNativeEvent;
    }

    /**
     * Defines replaceable undo service for editor
     */
    interface UndoService extends EditorPlugin {
        /**
         * Undo last change if any
         */
        undo: () => void;
        /**
         * Redo next change if any
         */
        redo: () => void;
        /**
         * Add an undo snapshot for current content inside editor
         * This method will not trigger ExtractContent event, so any temporary content will be
         * added into undo snapshot
         */
        addUndoSnapshot: () => void;
        /**
         * Whether there is snapshot for undo
         */
        canUndo: () => boolean;
        /**
         * Whether there is snapshot for redo
         */
        canRedo: () => boolean;
        /**
         * Clear all existing undo snapshots
         */
        clear: () => void;
    }

    /**
     * Clear a cached object by its key from an event object
     * @param event The event object
     * @param key The cache key
     */
    function clearEventDataCache(event: PluginEvent, key: string): void;

    /**
     * Gets the cached event data by cache key from event object if there is already one.
     * Otherwise, call getter function to create one, and cache it.
     * @param event The event object
     * @param key Cache key string, need to be unique
     * @param getter Getter function to get the object when it is not in cache yet
     */
    function cacheGetEventData<T>(event: PluginEvent, key: string, getter: () => T): T;

    /**
     * Build undo snapshot, remember current cursor position by inserting start and end cursor mark SPANs
     * @param editor The editor instance
     * @returns The snapshot HTML string
     */
    function buildSnapshot(editor: Editor): string;

    /**
     * Restore a snapshot, set the cursor selection back to the position stored in the snapshot
     * @param editor The editor instance
     */
    function restoreSnapshot(editor: Editor, snapshot: string): void;

    /**
     * Get the node at selection. If an expectedTag is specified, return the nearest ancestor of current node
     * which matches the tag name, or null if no match found in editor.
     * @param editor The editor instance
     * @param expectedTag The expected tag name. If null, return the element at cursor
     * @param startNode If specified, use this node as start node to search instead of current node
     * @returns The node at cursor or the nearest ancestor with the tag name is specified
     */
    function getNodeAtCursor(editor: Editor, expectedTag?: string, startNode?: Node): Node;

    /**
     * Get the node at selection from event cache if it exists.
     * If an expectedTag is specified, return the nearest ancestor of current node
     * which matches the tag name, or null if no match found in editor.
     * @param editor The editor instance
     * @param event Event object to get cached object from
     * @param expectedTag The expected tag name. If null, return the element at cursor
     * @returns The element at cursor or the nearest ancestor with the tag name is specified
     */
    function cacheGetNodeAtCursor(editor: Editor, event: PluginEvent, expectedTag: string): Node;

    /**
     * Query nodes intersected with current selection using a selector
     * @param editor The editor
     * @param selector The selector to query
     * @param nodeContainedByRangeOnly When set to true, only return the nodes contained by current selection. Default value is false
     * @param forEachCallback An optional callback to be invoked on each node in query result
     * @returns The nodes intersected with current selection, returns an empty array if no result is found
     */
    function queryNodesWithSelection<T extends Node = Node>(editor: Editor, selector: string, nodeContainedByRangeOnly?: boolean, forEachCallback?: (node: T) => void): T[];

    /**
     * Get format state at cursor
     * A format state is a collection of all format related states, e.g.,
     * bold, italic, underline, font name, font size, etc.
     * @param editor The editor
     * @param (Optional) The plugin event, it stores the event cached data for looking up.
     * In this function the event cache is used to get list state and header level. If not passed,
     * it will query the node within selection to get the info
     * @returns The format state at cursor
     */
    function getFormatState(editor: Editor, event?: PluginEvent): FormatState;

    /**
     * Read CursorData from plugin event cache. If not, create one
     * @param event The plugin event, it stores the event cached data for looking up.
     * If passed as null, we will create a new cursor data
     * @param editor The editor instance
     * @returns The cursor data
     */
    function cacheGetCursorEventData(event: PluginEvent, editor: Editor): TextBeforePositionTraverser;

    /**
     * Clear the cursor data in a plugin event.
     * This is called when the cursor data is changed, e.g, the text is replace with HyperLink
     * @param event The plugin event
     */
    function clearCursorEventDataCache(event: PluginEvent): void;

    /**
     * Clear the format in current selection, after cleaning, the format will be
     * changed to default format. The format that get cleaned include B/I/U/font name/
     * font size/text color/background color/align left/align right/align center/superscript/subscript
     * @param editor The editor instance
     */
    function clearFormat(editor: Editor): void;

    /**
     * Insert a hyperlink at cursor.
     * When there is a selection, hyperlink will be applied to the selection,
     * otherwise a hyperlink will be inserted to the cursor position.
     * @param editor Editor object
     * @param link Link address, can be http(s), mailto, notes, file, unc, ftp, news, telnet, gopher, wais.
     * When protocol is not specified, a best matched protocol will be predicted.
     * @param altText Optional alt text of the link, will be shown when hover on the link
     * @param displayText Optional display text for the link.
     * If there is a selection, this parameter will be ignored.
     * If not specified, will use link instead
     */
    function createLink(editor: Editor, link: string, altText?: string, displayText?: string): void;

    /**
     * Insert an image to editor at current selection
     * @param editor The editor instance
     * @param imageFile The image file. There are at least 3 ways to obtain the file object:
     * From local file, from clipboard data, from drag-and-drop
     */
    function insertImage(editor: Editor, imageFile: File): void;

    /**
     * Remove link at selection. If no links at selection, do nothing.
     * If selection contains multiple links, all of the link styles will be removed.
     * If only part of a link is selected, the whole link style will be removed.
     * @param editor The editor instance
     */
    function removeLink(editor: Editor): void;

    /**
     * Set content alignment
     * @param editor The editor instance
     * @param alignment The alignment option:
     * Alignment.Center, Alignment.Left, Alignment.Right
     */
    function setAlignment(editor: Editor, alignment: Alignment): void;

    /**
     * Set background color at current selection
     * @param editor The editor instance
     * @param color The color string, can be any of the predefined color names (e.g, 'red')
     * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.
     * Currently there's no validation to the string, if the passed string is invalid, it won't take affect
     */
    function setBackgroundColor(editor: Editor, color: string): void;

    /**
     * Set text color at selection
     * @param editor The editor instance
     * @param color The color string, can be any of the predefined color names (e.g, 'red')
     * or hexadecimal color string (e.g, '#FF0000') or rgb value (e.g, 'rgb(255, 0, 0)') supported by browser.
     * Currently there's no validation to the string, if the passed string is invalid, it won't take affect
     */
    function setTextColor(editor: Editor, color: string): void;

    /**
     * Change direction for the blocks/paragraph at selection
     * @param editor The editor instance
     * @param dir The direction option:
     * Direction.LeftToRight refers to 'ltr', Direction.RightToLeft refers to 'rtl'
     */
    function setDirection(editor: Editor, dir: Direction): void;

    /**
     * Set font name at selection
     * @param editor The editor instance
     * @param fontName The fontName string, should be a valid CSS font-family style.
     * Currently there's no validation to the string, if the passed string is invalid, it won't take affect
     */
    function setFontName(editor: Editor, fontName: string): void;

    /**
     * Set font size at selection
     * @param editor The editor instance
     * @param fontSize The fontSize string, should be a valid CSS font-size style.
     * Currently there's no validation to the string, if the passed string is invalid, it won't take affect
     */
    function setFontSize(editor: Editor, fontSize: string): void;

    /**
     * Set image alt text for all selected images at selection. If no images is contained
     * in selection, do nothing.
     * The alt attribute provides alternative information for an image if a user for some reason
     * cannot view it (because of slow connection, an error in the src attribute, or if the user
     * uses a screen reader). See https: * @param editor The editor instance
     * @param altText The image alt text
     */
    function setImageAltText(editor: Editor, altText: string): void;

    /**
     * Set indentation at selection
     * If selection contains bullet/numbering list, increase/decrease indentation will
     * increase/decrease the list level by one.
     * @param editor The editor instance
     * @param indentation The indentation option:
     * Indentation.Increase to increase indentation or Indentation.Decrease to decrease indentation
     */
    function setIndentation(editor: Editor, indentation: Indentation): void;

    /**
     * Toggle bold at selection
     * If selection is collapsed, it will only affect the following input after caret
     * If selection contains only bold text, the bold style will be removed
     * If selection contains only normal text, bold style will be added to the whole selected text
     * If selection contains both bold and normal text, bold stle will be added to the whole selected text
     * @param editor The editor instance
     */
    function toggleBold(editor: Editor): void;

    /**
     * Toggle bullet at selection
     * If selection contains bullet in deep level, toggle bullet will decrease the bullet level by one
     * If selection contains number list, toggle bullet will convert the number list into bullet list
     * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding
     * browser execCommand API
     * @param editor The editor instance
     */
    function toggleBullet(editor: Editor): void;

    /**
     * Toggle italic at selection
     * If selection is collapsed, it will only affect the input after caret
     * If selection contains only italic text, the italic style will be removed
     * If selection contains only normal text, italic style will be added to the whole selected text
     * If selection contains both italic and normal text, italic stlye will be added to the whole selected text
     * @param editor The editor instance
     */
    function toggleItalic(editor: Editor): void;

    /**
     * Toggle numbering at selection
     * If selection contains numbering in deep level, toggle numbering will decrease the numbering level by one
     * If selection contains bullet list, toggle numbering will convert the bullet list into number list
     * If selection contains both bullet/numbering and normal text, the behavior is decided by corresponding
     * realization of browser execCommand API
     * @param editor The editor instance
     */
    function toggleNumbering(editor: Editor): void;

    /**
     * Toggle blockquote at selection, if selection already contains any blockquoted elements,
     * the blockquoted elements will be unblockquoted and other elements will take no affect
     * @param editor The editor instance
     * @param styler (Optional) The custom styler for setting the style for the
     * blockquote element
     */
    function toggleBlockQuote(editor: Editor, styler?: (element: HTMLElement) => void): void;

    /**
     * Toggle strikethrough at selection
     * If selection is collapsed, it will only affect the input after caret
     * If selection contains only strikethrough text, the strikethrough style will be removed
     * If selection contains only normal text, strikethrough style will be added to the whole selected text
     * If selection contains both strikethrough and normal text, strikethrough stlye will be added to the whole selected text
     * @param editor The editor instance
     */
    function toggleStrikethrough(editor: Editor): void;

    /**
     * Toggle subscript at selection
     * If selection is collapsed, it will only affect the input after caret
     * If selection contains only subscript text, the subscript style will be removed
     * If selection contains only normal text, subscript style will be added to the whole selected text
     * If selection contains both subscript and normal text, the subscript style will be removed from whole selected text
     * If selection contains any superscript text, the behavior is determined by corresponding realization of browser
     * execCommand API
     * @param editor The editor instance
     */
    function toggleSubscript(editor: Editor): void;

    /**
     * Toggle superscript at selection
     * If selection is collapsed, it will only affect the input after caret
     * If selection contains only superscript text, the superscript style will be removed
     * If selection contains only normal text, superscript style will be added to the whole selected text
     * If selection contains both superscript and normal text, the superscript style will be removed from whole selected text
     * If selection contains any subscript text, the behavior is determined by corresponding realization of browser
     * execCommand API
     * @param editor The editor instance
     */
    function toggleSuperscript(editor: Editor): void;

    /**
     * Toggle underline at selection
     * If selection is collapsed, it will only affect the input after caret
     * If selection contains only underlined text, the underline style will be removed
     * If selection contains only normal text, underline style will be added to the whole selected text
     * If selection contains both underlined and normal text, the underline style will be added to the whole selected text
     * @param editor The editor instance
     */
    function toggleUnderline(editor: Editor): void;

    /**
     * Toggle header at selection
     * @param editor The editor instance
     * @param level The header level, can be a number from 0 to 6, in which 1 ~ 6 refers to
     * the HTML header element <H1> to <H6>, 0 means no header
     * if passed in param is outside the range, will be rounded to nearest number in the range
     */
    function toggleHeader(editor: Editor, level: number): void;

    /**
     * A virtual table class, represent an HTML table, by expand all merged cells to each separated cells
     */
    class VTable {
        /**
         * The HTML table object
         */
        table: HTMLTableElement;
        /**
         * Virtual cells
         */
        cells: VCell[][];
        /**
         * Current row index
         */
        row: number;
        /**
         * Current column index
         */
        col: number;
        private trs;
        /**
         * Create a new instance of VTable object using HTML table node
         * @param node The HTML Table node
         */
        constructor(table: HTMLTableElement);
        /**
         * Create a new instance of VTable object using one of its table cell
         * @param td The HTML table cell node
         */
        constructor(td: HTMLTableCellElement);
        /**
         * Write the virtual table back to DOM tree to represent the change of VTable
         */
        writeBack(): void;
        /**
         * Apply the given table format to this virtual table
         * @param format Table format to apply
         */
        applyFormat(format: TableFormat): void;
        /**
         * Loop each cell of current column and invoke a callback function
         * @param callback The callback function to invoke
         */
        forEachCellOfCurrentColumn(callback: (cell: VCell, row: VCell[], i: number) => void): void;
        /**
         * Loop each cell of current row and invoke a callback function
         * @param callback The callback function to invoke
         */
        forEachCellOfCurrentRow(callback: (cell: VCell, i: number) => void): void;
        /**
         * Get a table cell using its row and column index. This function will always return an object
         * even if the given indexes don't exist in table.
         * @param row The row index
         * @param col The column index
         */
        getCell(row: number, col: number): VCell;
        /**
         * Get current HTML table cell object. If the current table cell is a virtual expanded cell, return its root cell
         */
        getCurrentTd(): HTMLTableCellElement;
        /**
         * Move all children from one node to another
         * @param fromNode The source node to move children from
         * @param toNode Target node. If not passed, children nodes of source node will be removed
         */
        static moveChildren(fromNode: Node, toNode?: Node): void;
        /**
         * Clone a node without its children.
         * @param node The node to clone
         */
        static cloneNode<T extends Node>(node: T): T;
        /**
         * Clone a table cell
         * @param cell The cell to clone
         */
        static cloneCell(cell: VCell): VCell;
        private recalcSpans(row, col);
    }

    /**
     * Represent a virtual cell of a virtual table
     */
    interface VCell {
        /**
         * The table cell object. The value will be null if this is an expanded virtual cell
         */
        td?: HTMLTableCellElement;
        /**
         * Whether this cell is spanned from left
         */
        spanLeft?: boolean;
        /**
         * Whether this cell is spanned from above
         */
        spanAbove?: boolean;
    }

    /**
     * Insert table into editor at current selection
     * @param editor The editor instance
     * @param columns Number of columns in table, it also controls the default table cell width:
     * if columns <= 4, width = 120px; if columns <= 6, width = 100px; else width = 70px
     * @param rows Number of rows in table
     * @param format (Optional) The table format. If not passed, the default format will be applied:
     * background color: #FFF; border color: #ABABAB
     */
    function insertTable(editor: Editor, columns: number, rows: number, format?: TableFormat): void;

    /**
     * Edit table with given operation. If there is no table at cursor then no op.
     * @param editor The editor instance
     * @param operation Table operation
     */
    function editTable(editor: Editor, operation: TableOperation): void;

    /**
     * Format table
     * @param table The table to format
     * @param formatName Name of the format to use
     */
    function formatTable(editor: Editor, format: TableFormat, table?: HTMLTableElement): void;

    /**
     * An editor plugin to respond to default common keyboard short
     * i.e. Ctrl+B, Ctrl+I, Ctrl+U, Ctrl+Z, Ctrl+Y
     */
    class DefaultShortcut implements EditorPlugin {
        private editor;
        /**
         * Initialize this plugin
         * @param editor The editor instance
         */
        initialize(editor: Editor): void;
        /**
         * Dispose this plugin
         */
        dispose(): void;
        /**
         * Handle the event if it is a tab event, and cursor is at begin of a list
         */
        willHandleEventExclusively(event: PluginEvent): boolean;
        /**
         * Handle the event
         */
        onPluginEvent(event: PluginEvent): void;
    }

    /**
     * An editor plugin to show a tooltip for existing link and handle Ctrl+Click on a link
     */
    class HyperLink implements EditorPlugin {
        private getTooltipCallback;
        private target;
        private editor;
        /**
         * Create a new instance of HyperLink class
         * @param getTooltipCallback A callback function to get tooltip text for an existing hyperlink.
         * Default value is to return the href itself. If null, there will be no tooltip text.
         * @param target (Optional) Target window name for hyperlink. If null, will use "_blank"
         * @param linkMatchRules (Optional) Rules for matching hyperlink. If null, will use defaultLinkMatchRules
         */
        constructor(getTooltipCallback?: (href: string) => string, target?: string);
        /**
         * Initialize this plugin
         * @param editor The editor instance
         */
        initialize(editor: Editor): void;
        /**
         * Dispose this plugin
         */
        dispose(): void;
        /**
         * Handle plugin events
         * @param event The event object
         */
        onPluginEvent(event: PluginEvent): void;
        private resetAnchor;
        private processLink;
        private removeTempTooltip(content);
        private onClickLink;
        private tryGetHref(element);
    }

    /**
     * An editor plugin to handle content edit event.
     * The following cases are included:
     * 1. Auto increase/decrease indentation on Tab, Shift+tab
     * 2. Enter, Backspace on empty list item
     * 3. Enter, Backspace on empty blockquote line
     * 4. Auto bullet/numbering
     * 5. Auto link
     * 6. Tab in table
     */
    class ContentEdit implements EditorPlugin {
        private editor;
        private features;
        private keys;
        private backspaceUndoEventSource;
        private currentFeature;
        private autoLinkEnabled;
        /**
         * Create instance of ContentEdit plugin
         * @param features An optional feature set to determine which features the plugin should provide
         */
        constructor(featureSet?: ContentEditFeatures);
        /**
         * Initialize this plugin
         * @param editor The editor instance
         */
        initialize(editor: Editor): void;
        /**
         * Dispose this plugin
         */
        dispose(): void;
        /**
         * Check whether the event should be handled exclusively by this plugin
         */
        willHandleEventExclusively(event: PluginEvent): boolean;
        /**
         * Handle the event
         */
        onPluginEvent(event: PluginEvent): void;
        private addFeature(add, feature);
    }

    /**
     * Paste plugin, handles onPaste event and paste content into editor
     */
    class Paste implements EditorPlugin {
        private htmlPropertyCallbacks;
        private editor;
        private pasteDisposer;
        /**
         * Create an instance of Paste
         */
        constructor(htmlPropertyCallbacks?: SanitizeHtmlPropertyCallback);
        /**
         * Initialize this plugin
         * @param editor The editor instance
         */
        initialize(editor: Editor): void;
        /**
         * Dispose this plugin
         */
        dispose(): void;
        /**
         * Handle plugin events
         * @param event The event object
         */
        onPluginEvent(event: PluginEvent): void;
        private onPaste;
        /**
         * Paste into editor using passed in clipboardData with original format
         * @param clipboardData The clipboardData to paste
         */
        pasteOriginal(clipboardData: ClipboardData): void;
        /**
         * Paste plain text into editor using passed in clipboardData
         * @param clipboardData The clipboardData to paste
         */
        pasteText(clipboardData: ClipboardData): void;
        /**
         * Paste into editor using passed in clipboardData with curent format
         * @param clipboardData The clipboardData to paste
         */
        pasteAndMergeFormat(clipboardData: ClipboardData): void;
        private detectPasteOption(clipboardData);
        private paste(clipboardData, pasteOption, mergeCurrentFormat?);
        private internalPaste(event);
        private applyTextFormat(node, format);
    }

    /**
     * Feature set for ContentEdit plugin.
     * Call getDefaultContentEditFeatures() to get default feature set.
     */
    interface ContentEditFeatures {
        /**
         * When press Tab/Shift+Tab in a list, indent/outdent current list item
         * @default true
         */
        indentOutdentWhenTab: boolean;
        /**
         * When press BaskSpace on empty line which is the first item of a list, outdent current list item
         * @default true
         */
        outdentWhenBackspaceOnEmptyFirstLine: boolean;
        /**
         * When press Enter on empty line in a list, outdent current list item
         * @default true
         */
        outdentWhenEnterOnEmptyLine: boolean;
        /**
         * When press Backspace on first char in a list, make current item a new line of previous list item
         * @default false
         */
        mergeInNewLineWhenBackspaceOnFirstChar: boolean;
        /**
         * When press BAckspace on empty line which is the first line of a blockquote, unquote current line
         * @default true
         */
        unquoteWhenBackspaceOnEmptyFirstLine: boolean;
        /**
         * When press Enter on empty line in a blockquote, unquote current line
         * @default true
         */
        unquoteWhenEnterOnEmptyLine: boolean;
        /**
         * When press Space after an asterik in an empty line, create a bullet list
         * @default true
         */
        autoBullet: boolean;
        /**
         * When press Space or Enter after a hyperlink-like string, convert the string to a hyperlink
         */
        autoLink: boolean;
        /**
         * When press TAB or SHIFT+TAB key in table cell, jump to next/previous table cell
         * @default true
         */
        tabInTable: boolean;
    }

    /**
     * Get default feature set of ContentEdit plugin
     */
    function getDefaultContentEditFeatures(): ContentEditFeatures;

    /**
     * A plugin to support the functionality of resizing an inline image inside editor.
     */
    class ImageResize implements EditorPlugin {
        private minWidth;
        private minHeight;
        private selectionBorderColor;
        private forcePreserveRatio;
        private editor;
        private startPageX;
        private startPageY;
        private startWidth;
        private startHeight;
        private resizeDiv;
        private direction;
        /**
         * Create a new instance of ImageResize
         * @param minWidth Minimum width of image when resize in pixel, default value is 10
         * @param minHeight Minimum height of image when resize in pixel, default value is 10
         * @param selectionBorderColor Color of resize border and handles, default value is #DB626C
         * @param forcePreserveRatio Whether always preserve width/height ratio when resize, default value is false
         */
        constructor(minWidth?: number, minHeight?: number, selectionBorderColor?: string, forcePreserveRatio?: boolean);
        /**
         * Initialize this plugin
         * @param editor The editor instance
         */
        initialize(editor: Editor): void;
        /**
         * Dispose this plugin
         */
        dispose(): void;
        /**
         * Handle plugin events
         * @param event The event object
         */
        onPluginEvent(e: PluginEvent): void;
        private select(target);
        private unselect(selectImageAfterUnselect);
        private startResize;
        private doResize;
        private finishResize;
        private createResizeDiv(target);
        private removeResizeDiv(resizeDiv);
        private removeResizeDivIfAny;
        private extractHtml(html);
        private getSelectedImage();
        private isNorth(direction);
        private isWest(direction);
    }

    /**
     * A plugin to support the functionality of resizing a table inside editor.
     */
    class TableResize implements EditorPlugin {
        private editor;
        private onMouseOverDisposer;
        private td;
        private pageX;
        private initialPageX;
        /**
         * Initialize this plugin
         * @param editor The editor instance
         */
        initialize(editor: Editor): void;
        /**
         * Dispose this plugin
         */
        dispose(): void;
        /**
         * Handle plugin events
         * @param event The event object
         */
        onPluginEvent(event: PluginEvent): void;
        private clickIntoCurrentTd(event);
        private onMouseOver;
        private calcAndShowHandle();
        private adjustHandle(pageX);
        private getPosition(e);
        private getResizeHandle();
        private cancelEvent(e);
        private onMouseDown;
        private onMouseMove;
        private onMouseUp;
        private setTableColumnWidth(width);
        private isRtl(element);
    }

    /**
     * A watermark plugin to manage watermark string for roosterjs
     */
    class Watermark implements EditorPlugin {
        private watermark;
        private format;
        private editor;
        private isWatermarkShowing;
        private focusDisposer;
        private blurDisposer;
        /**
         * Create an instance of Watermark plugin
         * @param watermark The watermark string
         */
        constructor(watermark: string, format?: DefaultFormat);
        /**
         * Initialize this plugin
         * @param editor The editor instance
         */
        initialize(editor: Editor): void;
        /**
         * Dispose this plugin
         */
        dispose(): void;
        /**
         * Handle plugin events
         * @param event The event object
         */
        onPluginEvent(event: PluginEvent): void;
        private handleWatermark;
        private showHideWatermark(ignoreCachedState);
        private showWatermark();
        private hideWatermark();
        private removeWartermarkFromHtml(event);
    }

}